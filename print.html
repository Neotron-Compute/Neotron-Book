<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Neotron - The Embedded Rust Home Computer Platform</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> What is Neotron?</a></li><li class="chapter-item expanded "><a href="licence.html"><strong aria-hidden="true">2.</strong> Licence</a></li><li class="chapter-item expanded "><a href="credits.html"><strong aria-hidden="true">3.</strong> Credits</a></li><li class="chapter-item expanded affix "><li class="part-title">The Software</li><li class="chapter-item expanded "><a href="software.html"><strong aria-hidden="true">4.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="software_bios.html"><strong aria-hidden="true">5.</strong> The Neotron BIOS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="software_bios_apicalls.html"><strong aria-hidden="true">5.1.</strong> API Calls</a></li></ol></li><li class="chapter-item expanded "><a href="software_os.html"><strong aria-hidden="true">6.</strong> The Neotron OS</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="software_os_apicalls.html"><strong aria-hidden="true">6.1.</strong> API Calls</a></li></ol></li><li class="chapter-item expanded "><a href="software_command_shell.html"><strong aria-hidden="true">7.</strong> The Neotron Command Shell</a></li><li class="chapter-item expanded "><a href="software_menu_shell.html"><strong aria-hidden="true">8.</strong> The Neotron Command Menu</a></li><li class="chapter-item expanded "><a href="software_applications.html"><strong aria-hidden="true">9.</strong> Neotron Applications</a></li><li class="chapter-item expanded affix "><li class="part-title">The Hardware</li><li class="chapter-item expanded "><a href="hardware.html"><strong aria-hidden="true">10.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="hardware_soc.html"><strong aria-hidden="true">11.</strong> The System On Chip</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hardware_soc_video.html"><strong aria-hidden="true">11.1.</strong> Video</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.2.</strong> Audio</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.3.</strong> GPIO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.4.</strong> SPI Bus</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.5.</strong> I²C Bus</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.6.</strong> UART/MIDI</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.7.</strong> RTC</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.8.</strong> SD Card</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.9.</strong> USB</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Expanding the System</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> Video</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.2.</strong> Audio</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.3.</strong> GPIO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.4.</strong> UART/MIDI/RS-232</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.5.</strong> RTC</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.6.</strong> SD Card</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.7.</strong> Keyboard/Mouse</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.8.</strong> Ethernet</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.9.</strong> Wi-Fi</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.10.</strong> Bluetooth</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.11.</strong> USB</div></li></ol></li><li class="chapter-item expanded "><a href="hardware_baseboards.html"><strong aria-hidden="true">13.</strong> Baseboards</a></li><li class="chapter-item expanded affix "><li class="part-title">Neotron Systems</li><li class="chapter-item expanded "><a href="systems.html"><strong aria-hidden="true">14.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="neotron_32.html"><strong aria-hidden="true">15.</strong> Neotron 32</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="neotron_32_video.html"><strong aria-hidden="true">15.1.</strong> Video</a></li><li class="chapter-item expanded "><a href="neotron_32_audio.html"><strong aria-hidden="true">15.2.</strong> Audio</a></li><li class="chapter-item expanded "><a href="neotron_32_sdmmc.html"><strong aria-hidden="true">15.3.</strong> SD Card Slot</a></li><li class="chapter-item expanded "><a href="neotron_32_ps2.html"><strong aria-hidden="true">15.4.</strong> PS/2 and Joystick</a></li><li class="chapter-item expanded "><a href="neotron_32_wifi.html"><strong aria-hidden="true">15.5.</strong> WiFi</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.6.</strong> Expansion</div></li><li class="chapter-item expanded "><a href="neotron_32_parallel.html"><strong aria-hidden="true">15.7.</strong> Parallel Port</a></li><li class="chapter-item expanded "><a href="neotron_32_rs232.html"><strong aria-hidden="true">15.8.</strong> RS-232</a></li><li class="chapter-item expanded "><a href="neotron_32_midi.html"><strong aria-hidden="true">15.9.</strong> MIDI</a></li><li class="chapter-item expanded "><a href="neotron_32_usb.html"><strong aria-hidden="true">15.10.</strong> USB</a></li><li class="chapter-item expanded "><a href="neotron_32_rtc.html"><strong aria-hidden="true">15.11.</strong> RTC</a></li></ol></li><li class="chapter-item expanded "><a href="neotron_pico.html"><strong aria-hidden="true">16.</strong> Neotron Pico</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="neotron_pico_video.html"><strong aria-hidden="true">16.1.</strong> Video</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.2.</strong> Audio</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.3.</strong> SD Card Slot</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.4.</strong> PS/2</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.5.</strong> Expansion</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.6.</strong> USB</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.7.</strong> RTC</div></li></ol></li><li class="chapter-item expanded "><a href="neotron_340st.html"><strong aria-hidden="true">17.</strong> Neotron 340ST</a></li><li class="chapter-item expanded "><a href="neotron_500.html"><strong aria-hidden="true">18.</strong> Neotron 500</a></li><li class="chapter-item expanded "><a href="neotron_600.html"><strong aria-hidden="true">19.</strong> Neotron 600</a></li><li class="chapter-item expanded "><a href="neotron_1000.html"><strong aria-hidden="true">20.</strong> Neotron 1000</a></li><li class="chapter-item expanded "><a href="neotron_9x.html"><strong aria-hidden="true">21.</strong> Neotron 9X</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Neotron - The Embedded Rust Home Computer Platform</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#what-is-neotron" id="what-is-neotron">What is Neotron?</a></h1>
<p>Neotron is an attempt to make computers simple again, whilst also taking advantage of the very latest in programming language development. We are saddened by chat clients that require multi-Gigabyte installs, and systems with hundreds of millions of lines of source code that no one person could ever hope to understand. We want to build a machine that is sized for an individual to comprehend, not a trillion-dollar corporation.</p>
<p>If you want a pithy sound-bite, it's like CP/M for tiny ARM microcontrollers, but written in Rust.</p>
<h2><a class="header" href="#tell-me-more" id="tell-me-more">Tell me more...</a></h2>
<p>Neotron is based around four fundamental components.</p>
<ul>
<li>A standardised OS interface, for portable Applications to call. This provides APIs for reading/writing files, accessing devices, writing to the screen, playing audio, etc.</li>
<li>A standardised BIOS interface, for the Operating System to call. The BIOS abstracts the specific hardware implementation of the Video, Audio, UART, SPI, I2C, GPIO, Disk Drive, Parallel Printer, Keyboard and Mouse interfaces. By using the BIOS, we should be able to run the <em>exact same</em> Neotron OS on a variety of different microcontrollers.</li>
<li>Use of the Rust Programming Language to write as much of the software as possible (we avoid raw assembler as much as possible, but we're happy to port existing applications that are written in C even if we avoid that language in the system software).</li>
<li>The ARM Thumb-v7M instruction set (as supported by ARM Cortex-M based microcontrollers from the M3 and up). This is what allow us to run the same programs on microcontrollers from different vendors.</li>
</ul>
<p>Looking back at classic home computers of the 1980s and early 1990s though, we see systems that were (and still are) simple enough to understand, or even - with time - to learn to master. Here's a rough comparison with just a few of the classic systems we have taken as inspiration (where not otherwise specified, these are the first version launched of a given system):</p>
<table><thead><tr><th align="left">Feature</th><th align="left">Neotron 32</th><th align="left">Neotron Pico</th><th align="left">IBM PC</th><th align="left">BBC Micro</th><th align="left">Commodore 64</th><th align="left">Apple Macintosh</th><th align="left">Amstrad PCW</th><th align="left">Amiga</th><th align="left">Acorn Archimedes</th></tr></thead><tbody>
<tr><td align="left">Launch Year</td><td align="left">2020</td><td align="left">2021</td><td align="left">1981</td><td align="left">1981</td><td align="left">1982</td><td align="left">1984</td><td align="left">1985</td><td align="left">1985</td><td align="left">1987</td></tr>
<tr><td align="left">Instruction Set</td><td align="left">ARMv7E-M</td><td align="left">ARMv6-M</td><td align="left">Intel x86</td><td align="left">MOS 6502</td><td align="left">MOS 6502</td><td align="left">Motorola 68k</td><td align="left">Zilog Z80</td><td align="left">Motorola 68k</td><td align="left">ARM v2</td></tr>
<tr><td align="left">CPU</td><td align="left">Cortex-M4</td><td align="left">2x Cortex-M0+</td><td align="left">8088</td><td align="left">6502A</td><td align="left">6510</td><td align="left">68000</td><td align="left">Z80A</td><td align="left">68000</td><td align="left">ARM2</td></tr>
<tr><td align="left">Clock Speed</td><td align="left">80 MHz</td><td align="left">2x 133 MHz</td><td align="left">4.77 MHz</td><td align="left">2 MHz</td><td align="left">1 MHz</td><td align="left">8 MHz</td><td align="left">4 MHz</td><td align="left">8 MHz</td><td align="left">8 MHz</td></tr>
<tr><td align="left">Low Level OS</td><td align="left">Neotron BIOS</td><td align="left">Neotron BIOS</td><td align="left">IBM BIOS</td><td align="left">Acorn MOS</td><td align="left">KERNAL</td><td align="left">Toolbox</td><td align="left">XBIOS</td><td align="left">Kickstart</td><td align="left">RISC OS</td></tr>
<tr><td align="left">High Level OS</td><td align="left">Neotron OS</td><td align="left">Neotron OS</td><td align="left">PC-DOS 1.0</td><td align="left">Acorn MOS</td><td align="left">N/A</td><td align="left">System</td><td align="left">CP/M Plus</td><td align="left">AmigaDOS</td><td align="left">RISC OS</td></tr>
<tr><td align="left">Shell</td><td align="left">Neotron Shell</td><td align="left">Neotron Shell</td><td align="left">COMMAND .COM</td><td align="left">BBC BASIC</td><td align="left">BASIC v2</td><td align="left">Finder</td><td align="left">CP/M CCP</td><td align="left">Workbench</td><td align="left">RISC OS Desktop</td></tr>
<tr><td align="left">Primary Language</td><td align="left">Rust</td><td align="left">Rust</td><td align="left">Assembly / C</td><td align="left">Assembly</td><td align="left">Assembly</td><td align="left">Object Pascal</td><td align="left">Assembly</td><td align="left">BCPL / C</td><td align="left">Assembly / BBC BASIC</td></tr>
<tr><td align="left">ROM</td><td align="left">256K</td><td align="left">2048K</td><td align="left">8K</td><td align="left">32K</td><td align="left">16K</td><td align="left">64K</td><td align="left">256 bytes</td><td align="left">256K</td><td align="left">512K</td></tr>
<tr><td align="left">RAM</td><td align="left">32K</td><td align="left">256K</td><td align="left">16K to 256K</td><td align="left">32K</td><td align="left">64K</td><td align="left">128K</td><td align="left">64K</td><td align="left">256K</td><td align="left">512K</td></tr>
<tr><td align="left">Self-hosting</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr>
</tbody></table>
<p>The <a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer">IBM PC</a> BIOS was stored in a ROM chip on the motherboard. It provided a certain level of hardware abstraction, with APIs for writing to the screen, setting the video mode and reading/writing from block devices such as floppy drives. The BIOS initialised the hardware, loaded the first sector of a chosen block device into RAM and then executed the code contained within. This was the Boot Sector and contained enough code to load the rest of the Operating System. PC-DOS made use of BIOS APIs, but often games would bypass both MS-DOS and the BIOS and access hardware directly. Famously, Microsoft was able to sell copies of PC-DOS (relabelled as MS-DOS) to manufacturers of 'PC compatibles', provided they had a BIOS ROM which offered the same (reverse-engineered) API as the IBM BIOS.</p>
<p>The <a href="https://en.wikipedia.org/wiki/BBC_Micro">BBC Micro</a> had a very advanced Operating System for the time, known as the Acorn Machine Operating System (MOS). You could add extra ROMs to the system, such as the Disk Filing System (DFS). BBC BASIC was also very advanced for the time, including a built-in 6502 assembler.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Commodore_64">Commodore 64</a> contained two 8 KiB ROM chips - one contained the OS (called the KERNAL) and one contained a rebadged Microsoft 6502 BASIC. The KERNAL was very low level and Microsoft BASIC didn't include any commands to produce graphics or sound - developers were expected to interact with memory mapped hardware directly. The C64 KERNAL could be assembled using PET RESIDENT ASSEMBLER on a Commodore PET, but the <a href="https://www.pagetable.com/?p=774">Microsoft BASIC source code</a> was written on a PDP-10 using the MACRO-10 assembler.</p>
<p>The original <a href="https://en.wikipedia.org/wiki/Macintosh_128K">Apple Macintosh</a> had a ROM on the motherboard which initialised the hardware and drew a graphical image on the screen indicating that the user should insert the System disk. The ROM then loaded the OS (known as <em>System</em> up to version 7, and <em>Mac OS</em> for versions 8 and 9) into RAM, along with a graphical desktop called Finder. Applications on the Macintosh (including the Finder) made use of a number of graphical routines stored in the ROM, known as the <em>Macintosh Toolbox</em>.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Amstrad_PCW">Amstrad PCW8256</a> was similar to the Amiga 1000 in that the main BIOS was loaded from floppy disk. Going further than the Amiga though, the PCW didn't include a ROM chip at all. Instead the 256 bytes of bootstrap code were loaded from the microcontroller responsible for managing the printer interface. The bootstrap loaded the so-called <em>XBIOS</em> from floppy disk into RAM. XBIOS then initialised the hardware and loaded CP/M Plus (also known as CP/M 3.0). The shell was the familiar CP/M Command Console Processor (CCP), and both the OS and the CCP were the same across a wide range of CP/M machines from many different vendors, with the BIOS providing the hardware abstraction layer.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Amiga_1000">Amiga 1000</a> hardware didn't include much in the way of a ROM at all. A basic bootstrap program stored in ROM was able to load most of the low-level OS (known as <em>Kickstart</em>) into a special write-only area of RAM. Kickstart could then load either the particular game being played, or AmigaDOS and a graphical shell known as Workbench. On later machines (such as the A500), the Kickstart was stored in ROM.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Acorn_Archimedes">Acorn Archimedes</a> was first shipped with an OS in ROM called Arthur, but this was soon replaced with the more familiar RISC OS 2 (and later RISC OS 3). The entire OS - bootstrap, HAL, filesystem and GUI - was one on ROM chip, meaning it booted up very quickly, without needing to read from any sort of disc.</p>
<p>The key feature for many these systems (apart from the Commodore 64), was portability across other machines in the family (or, indeed, third-party clones). The PC, the Amiga, the Macintosh and CP/M all provided a <em>platform</em>, and if you respected certain limits when writing your software, that software was then portable across all the systems which provided that platform. For Neotron, this is a key concept - because microcontrollers vary so wildly, we have a BIOS that implements hardware abstraction, just like with the PC or CP/M machines. We then run a standard OS (indeed, the same OS image should work on every Neotron machine - more-or-less), either from ROM or loaded into RAM by the BIOS. On top of the OS is the text-mode Neotron Shell (like CP/M's CCP, or MS-DOS's COMMAND.COM). Booting to a graphical desktop would be nice, but given the Neotron 32 only has 32 KiB of RAM (barely enough for a low resolution frame-buffer), text mode is the default. Ultimately, a Neotron 32 should be able to 'compete' on a functional level with an un-expanded IBM PC 5150 or a BBC Microcomputer Model-B. The Neotron Pico meanwhile, could be more like a Macintosh, Archimedes or Amiga in terms of functionality and in time we do hope to develop a GUI for this system.</p>
<p>As with the CP/M and MS-DOS machines, we hope that in the future there will be a wide range of machines in the Neotron family. These Neotron systems won't generally aim to be super cheap, although we will tend to target commodity microcontrollers that only cost circa $10 or less, so they shouldn't be outrageously expensive. They will, however, aim to be usable computers that can do interesting things, while being simple enough to understand in their entirety and open enough to allow you to gain that understanding.</p>
<h2><a class="header" href="#what-can-i-do-with-it" id="what-can-i-do-with-it">What can I do with it?</a></h2>
<p>You can do what you can do with most 1980s home computers:</p>
<ul>
<li>Type things on the keyboard.</li>
<li>Use a joystick or a mouse.</li>
<li>Manage files on internal or removable storage.</li>
<li>Load programs from internal or removable storage.</li>
<li>Type in your own programs.</li>
<li>Put text and graphics on the screen.</li>
<li>Make various beepy noises.</li>
<li>Connect various internal expansion cards or external peripherals.</li>
<li>Expand the system in ways the designer couldn't imagine.</li>
</ul>
<p>But most importantly, you can learn the fundamentals of what it takes for a computer to be a <em>computer</em>. And you can study the source code and hardware schematics required to make that happen. You can even take the designs and go off and produce your own version - maybe to add a specific interface for a particular peripheral that interests you - all with no licence fees to pay.</p>
<h2><a class="header" href="#what-cant-i-do-with-it" id="what-cant-i-do-with-it">What can't I do with it?</a></h2>
<p>A Neotron system will probably never:</p>
<ul>
<li>Support multiple processes (although Windows 3.1-style co-operative task switching is plausible).</li>
<li>Support 3D graphics (e.g. OpenGL).</li>
<li>Support virtual addressing (i.e. make use of an MMU).</li>
<li>Be POSIX compatible.</li>
<li>Have a huge software library (or probably any real library of software).</li>
<li>Run existing MS-DOS, Windows or Linux programs.</li>
<li>Be able to run <code>rustc</code>.</li>
<li>Have a port of Rust's <code>libstd</code>.</li>
<li>Be directly targetable from Rust with <code>--target=thumbv7em-unknown-neotron-eabi</code>.</li>
<li>Be useful for day to day use.</li>
<li>Be finished.</li>
</ul>
<p>If you want a decent open-source UNIX Operating System, have a look at <em>FreeBSD</em> (or <em>NetBSD</em>, or <em>OpenBSD</em>). If you want a small teaching-oriented open-source UNIX Operating System, look at <em>XV6</em>, or maybe <em>MINIX 3</em>. If you want to learn about Linux, try <em>Linux from Scratch</em>. If you want to learn an ancient Arm based Operating System which still has a flavour of the original BBC Microcomputer, look at <em>RISC OS</em> (it's open source now). If you want a proper OS written in Rust, look at <em>Redox</em>. And if you want to do any of that on a system you don't have, try qemu, or rpcemu.</p>
<h2><a class="header" href="#is-this-a-good-idea" id="is-this-a-good-idea">Is this a good idea?</a></h2>
<p>It's certainly not a profitable idea. It's not even likely to be an efficient use of our time and resources. But it is proving to be a fun and educational project to work on, and we hope others find it useful and/or enjoyable too.</p>
<h2><a class="header" href="#but-what-about-existing_product" id="but-what-about-existing_product">But what about ${EXISTING_PRODUCT}?</a></h2>
<h3><a class="header" href="#raspberry-pi" id="raspberry-pi">Raspberry Pi</a></h3>
<p>Yes, you can buy a Raspberry Pi for a little as $5 - and it's a wonderful product that has done arguably more than anything since the BBC Microcomputer in terms of putting hardware you can actually program into the hands of young people. But, the downside is that you get a big, complicated piece of silicon, a proprietary GPU subsystem, 25 million lines of kernel source code, and even more in a user-land which has parts dating back over 30 years. No one person could hope to understand all of that! While we could probably port the Neotron OS to the Raspberry Pi, we'd have to treat the video sub-system as a black-box (like RISC OS does) and the complexity and lack of documentation of that subsystem presents a big barrier to fully understanding the system. Not to mention the the fact that only partial schematics are available, there are no PCB designs available, and there's no general availability on the main processor. It does what it needs to do for its target market quite admirably - but it's not a Neotron.</p>
<h3><a class="header" href="#x86-based-systems-like-the-original-ibm-pc" id="x86-based-systems-like-the-original-ibm-pc">x86 based systems, like the original IBM PC</a></h3>
<p>You could build yourself a clone of the original IBM PC (<a href="https://monotech.fwscart.com/">kits do exist</a>), but it involves a lot of components that are very difficult to obtain nearly 40 years since that design first came out. Rust is also designed around a flat memory model (rather than the segmentation:offset model used by the 16-bit 8086), and that means using at least a 32-bit <a href="https://hackaday.com/2015/11/17/a-modern-386-development-board/">Intel 80386</a>. And, of course, these are plain CPUs rather than microcontrollers, so you'll need to find a 'chipset' containing interrupt controller, DRAM memory controller and timers; as well as separate video, sound and IO sub-systems. Our System-on-Chip based design simplifies the motherboard design and reduces cost, and unlike with modern x86 SoCs, we don't have to deal with complicated legacy subsystems such as UEFI, ACPI or PCI.</p>
<h3><a class="header" href="#6502-based-systems-like-the-pe6502-and-commander-x16" id="6502-based-systems-like-the-pe6502-and-commander-x16">6502 based systems (like the PE6502 and Commander X16)</a></h3>
<p>You could build a 6502 based system, and many people do, but the Rust programming language doesn't (and probably never will) support an 8-bit CPU with only 256 bytes of stack.</p>
<h3><a class="header" href="#68000-based-systems" id="68000-based-systems">68000 based systems</a></h3>
<p>At the present time, there is no 68k backend in LLVM. If there was, a 68000 system would certainly make an interesting alternative to Neotron, although the 68000 processors available are more expensive and less powerful than a modern commodity Arm microcontroller.</p>
<h3><a class="header" href="#powerpc-based-systems" id="powerpc-based-systems">PowerPC based systems</a></h3>
<p>LLVM does have a PowerPC backend, but unfortunately most PowerPC based chips only come in monster 380+ pin BGA packages, with multiple power rails. This unfortunately puts them beyond the scope of a simple hobby project, much as the author would love to build a machine that harks back to the IBM RS/6000 and Power Macintosh machines of the 1990s.</p>
<h3><a class="header" href="#risc-v-based-systems" id="risc-v-based-systems">RISC-V based systems</a></h3>
<p>There are an increasing number of RISC-V based microcontrollers with very small SRAMs, matched by an increasing number of multi-core 64-bit SoCs designed to run Linux from a huge bank of DDR3. At the current time, however, there isn't much in the middle.</p>
<p>A Neotron system built around an open-source RISC-V code run from an FPGA would be an interesting way to increase the openness of the system and remains a future possibility. The simplicity of the RISC-V ISA is also appealing, as compared to the, umm, <em>evolved</em> nature of ARMv6-M.</p>
<h3><a class="header" href="#sparc-based-systems" id="sparc-based-systems">SPARC based systems</a></h3>
<p>The Gaisler LEON3 is available in VHDL form under the GPL, along with a number of other components required to make a full SoC. The LEON3 implements the SPARC V8 ISA, support for which is available in the Rust compiler. However, this would require an FPGA based system and it's unknown whether the full GRLIB SoC would fit into any of the FPGAs supported by the various open-source FPGA synthesis tools (such as the Lattice iCE40).</p>
<h3><a class="header" href="#atmel-avr-based-systems" id="atmel-avr-based-systems">Atmel AVR based systems</a></h3>
<p>Many people have built Atmel AVR based systems, but those CPUs are fairly limited in terms of performance and tend to need to be programmed in raw assembler, or at least non-portable C (such as when storing strings in program memory with a 24-bit pointer instead of in data memory with an 8-bit pointer). There is a Rust AVR port, but it's only in an alpha state at the moment.</p>
<h3><a class="header" href="#mips32-based-systems-like-the-pic32" id="mips32-based-systems-like-the-pic32">MIPS32 based systems, like the PIC32</a></h3>
<p>The PIC32 family would make a very interesting home computer. Indeed, a PIC32 can be found in the Colour Maximite. I think it is telling though that the next revision of the Colour Maximite switched over to a Cortex-M7 based STM32H7. You could also point to the fact that  MIPS themselves have publicly switched to producing RISC-V designs that maybe this architecture doesn't have the best future ahead of it.</p>
<h2><a class="header" href="#what-is-this-book" id="what-is-this-book">What is this book?</a></h2>
<p>This book describes the Neotron system - from the hardware schematics, all the way up to how to write applications for the system. It is intended to be the canonical reference, although where the source code differs from what is described in this book, we reserve the right to be pragmatic and change either to match the other (or leave them in disagreement...). This book also represents our latest thoughts on a particular topic, and the source code may lag behind while we get around to the implementation. We endeavour to note where this is the case.</p>
<h2><a class="header" href="#versioning" id="versioning">Versioning</a></h2>
<p>Each component has a semantic version number - <code>major.minor.patch</code>. The association is:</p>
<ul>
<li>The BIOS will require a compatible hardware version.</li>
<li>The OS will require a compatible BIOS version.</li>
<li>The Shell and Applications will require a compatible OS version.</li>
</ul>
<h1><a class="header" href="#licence" id="licence">Licence</a></h1>
<p>Neotron is designed to be open - the user must have free rein to inspect the source code and the schematics, and change them to suit their needs. To this end, the main BIOS and OS implementations are licensed under the <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GNU Public Licence v3</a> or any later version. To encourage the adoption of Rust for embedded development, most of the library crates developed for this project are licensed under both the <a href="https://opensource.org/licenses/MIT">MIT</a> and <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a> licences, just like the Rust compiler itself. We do intend to sell a range of kits and pre-built PCBs, but you can (and should!) take our designs as inspiration and put your own spin on them.</p>
<p>This book is licensed under Creative Commons <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">CC-BY-SA 4.0</a>. Any source examples in this book may also be used under the <a href="https://opensource.org/licenses/MIT">MIT</a> or <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a> licences.</p>
<h1><a class="header" href="#credits" id="credits">Credits</a></h1>
<p>Neotron started as a project called 'Monotron', by <a href="https://github.com/thejpster">@thejpster</a>. This was based on the work of the <a href="https://github.com/rust-embedded">Rust Embedded Working Group</a>, and inspiration from the following (in no particular order):</p>
<ul>
<li><a href="http://geoffg.net/maximite.html">Colour Maximite</a> - A modern PIC32 based single-board home computer.</li>
<li><a href="http://putnamelectronics.com/products.html">PE6502</a> - A modern 6502 based single-board home computer.</li>
<li><a href="https://gigatron.io/">Gigatron</a> - A single-board home computer, with a custom CPU built from TTL logic chips.</li>
<li><a href="http://commanderx16.com/">Commander X16</a> - A single-board home computer, with a 6502 and an FPGA based video chip.</li>
<li><a href="http://www.linusakesson.net/scene/craft/">Craft</a> - Demonstrates bit-bashing VGA from an AtMega88</li>
<li><a href="http://tinyvga.com/avr-isa-vga">AVR-ISA</a> - Demonstrates driving an ISA bus (and an ISA VGA card) driven from an AtMega128</li>
<li>The Commodore 64C - <a href="https://github.com/thejpster">@thejpster</a>'s first home computer</li>
<li>The BBC Microcomputer range (the Model B through to the Archimedes A3000) - as used in UK schools in the 1980s</li>
<li>The Amstrad range of CP/M machines, particularly the PCW9512</li>
</ul>
<p>After meeting <a href="https://github.com/IGBC">@IGBC</a> at Oxidize 2019, discussions started around a next-generation system with higher performance. This led to the Neotron 1000, and then to the whole Neotron concept. We've also great benefited from conversations with <a href="https://github.com/jamesmunns">@jamesmunns</a>, and others in the Rust Embedded Working Group.</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>The software in a Neotron system is divided into layers. This approach allows each layer to concentrate on its own areas of responsibility (known as <a href="https://en.wikipedia.org/wiki/Separation_of_concerns"><em>separation of concerns</em></a>). These layers are arranged into a stack, with the interface to the physical hardware at the bottom, and the user application at the very top.</p>
<pre><code>+---------+-------------+
|         |             |
|  Shell  | Application |
|         |             |
+---------+-------------+
|                       |
|    Operating System   |
|                       |
+-----------------------+
|                       |
|         BIOS          |
|                       |
+-----------------------+
|                       |
|     Embedded HAL      |
|                       |
+-----------------------+
|                       |
|Peripheral Access Crate|
|                       |
+-----------------------+
|                       |
|      Raw Hardware     |
|                       |
+-----------------------+
</code></pre>
<h1><a class="header" href="#the-neotron-bios" id="the-neotron-bios">The Neotron BIOS</a></h1>
<h2><a class="header" href="#introduction-1" id="introduction-1">Introduction</a></h2>
<p>The Neotron BIOS is the hardware-abstraction layer for the Neotron Operating
System. It allows the OS to run on different hardware platforms with the minimum
number of changes.</p>
<pre><code>+-------+-------------+
|       |             |
| Shell | Application |
|       |             |
+-------+-------------+
|                     |
|  Operating System   |
|                     |
++===================++
||                   ||
||       BIOS        ||
||                   ||
++===================++
|                     |
|    Raw Hardware     |
|                     |
+---------------------+
</code></pre>
<h2><a class="header" href="#what-goes-in-the-bios-and-what-goes-in-the-os" id="what-goes-in-the-bios-and-what-goes-in-the-os">What goes in the BIOS and what goes in the OS?</a></h2>
<p>As a general rule, the BIOS should contain all the drivers for the main
system-on-chip (SoC) in that particular Neotron system. It should also
understand which pins on the SoC have been assigned to which functions. It is
therefore a function of the netlist for the main PCB, and the components fitted
to it.</p>
<p>If a particular function might apply to SoCs from different manufacturers, or to
an expansion card that could be inserted into multiple different models of
Neotron system, it is probably better placed in the Neotron OS.</p>
<h2><a class="header" href="#interfaces" id="interfaces">Interfaces</a></h2>
<p>A BIOS should offer an interface upwards to the OS so that the OS can:</p>
<ul>
<li>Discover the hardware in the system</li>
<li>Select and use various video modes:
<ul>
<li>Text modes</li>
<li>Bitmap graphics modes</li>
<li>Split modes</li>
<li>Layered Modes</li>
<li>Hooking video scan-line interrupts</li>
</ul>
</li>
<li>Read any keyboard key events</li>
<li>Access (read from, write to and/or configure) any Serial/UART interfaces</li>
<li>Access any I²C buses, and any devices attached to its bus</li>
<li>Access any SPI buses, and any devices attached to its chip selects</li>
<li>Access any USB Host Controllers, and any USB devices attached</li>
<li>Access any block devices, via whatever interface they are connected to</li>
<li>Read from / write from any audio FIFOs</li>
<li>Configure a periodic 'system tick' timer</li>
<li>Obtain / set the current calendar time</li>
<li>Measure elapsed time since boot-up (e.g. in microseconds)</li>
<li>Hook interrupts for the external IRQ lines</li>
<li>Access any OS-specific non-volatile configuration</li>
</ul>
<p>On top of these APIs sits the Neotron OS, which should be portable with almost
zero changes to any device with a Neotron BIOS. While you could write an
application which uses the BIOS directly, most applications will use the
higher-level APIs exposed by the Neotron OS.</p>
<h2><a class="header" href="#configuration" id="configuration">Configuration</a></h2>
<p>Many Neotron sytems will have an element of user configuration to them - e.g.
which cards are fitted to which expansion slots, or whether an optional item has
been fitted to the PCB. To handle this, it is expected that the BIOS have some
kind of configuration application, and some non-volatile storage that will hold
the configuration across a power cycle. Typically this will be in the
battery-backed real-time clock, but it could equally be in an EEPROM.</p>
<h2><a class="header" href="#calling-a-bios-api" id="calling-a-bios-api">Calling a BIOS API</a></h2>
<p>On ARM systems, calling a kernel API is usually done through a <code>SWI</code> or <code>SVC</code>
machine instruction. This effectively triggers an interrupt, putting the CPU
into interrupt mode where it starts executing the <code>SWI</code> exception handler.
Unfortunately, calling the <code>SWI</code> instruction and passing arguments via registers
can only be performed from assembly language, and is not supported by the
<code>cortex-m</code> crate at this time.</p>
<p>Monotron instead used a simple alternative - when the application was started by
the OS, the OS passed it a pointer to a structure of function pointers. You can
think of this as being like an old-fashioned jump table. When the application
wanted to get the OS to do something, the application just called the
appropriate function through the given pointer. The downside was that the
Monotron OS functions used the same stack as the application, and it was
impossible for an application to exit back to the OS unless it returned from
<code>main</code> (i.e. there was no <code>exit()</code> function you could call). The Neotron BIOS
accepts these downsides in the same of simplicity, and takes the Monotron
approach - at least for the BIOS-OS ABI.</p>
<p>The BIOS is responsible for starting the system and performing hardware
initialisation. It will also search for the OS, either in Flash memory, on disk, or
perhaps even loaded over a UART. The OS then has its initialisation function
called, to which the structure of BIOS function calls is passed. The
initialisation function is specified as a function pointer stored at a
specific offset (most likely the first four bytes of the OS image). To avoid
undefined behaviour, that initialisation function should memset the <code>.bss</code>
section to all-zeroes and, if necessary, initialise the <code>.data</code> section using
values stored in Flash memory.</p>
<p>Most of the BIOS APIs will be 'blocking' - that is, the function call will not
return until the BIOS has completed the operation (e.g. read the sector from
disk, or written the bytes to the UART). It is possible in the future that BIOS
APIs will be added which allows operations to be <em>asynchronous</em> - that is, to
return immediately once the operation has been <em>queued</em> and then either call
some function or set some marker value in memory once the operation has been
completed. Such an API is more complex to develop, and has interesting
challenges around ensuring the memory passed to the function remains available
(i.e. it isn't just on the stack of the calling function). However, these APIs
are generally more efficient in terms of CPU time, as the CPU does not have to
waste cycles spinning in the main thread whilst it waits for the operation to
complete - for example, you could be writing some sectors to disk and performing
an I²C read from the HID controller asynchronously, whilst also calculating new
display graphics and audio in the main thread.</p>
<p>For now however, the blocking APIs were sufficient for MS-DOS, and they will be
sufficient here.</p>
<h2><a class="header" href="#why-split-the-os-and-the-bios" id="why-split-the-os-and-the-bios">Why split the OS and the BIOS?</a></h2>
<p>We could take the Linux / Windows NT approach, with a boot-loader that performs
the bare minimum required to get the kernel (or, in our case, what we call the
'OS') into RAM and start it running. The boot-loader for a PC is usually a UEFI
BIOS but on an older system might be an IBM PC-compatible 'legacy' BIOS. The
operations performed typically include DRAM setup, rudimentary console setup
(either frame-buffer or over UART) and accessing the kernel from some kind of
block device or non-volatile memory (e.g. SD Card). The kernel then replaces
the boot-loader, which is never used again.</p>
<p>Because our Neotron systems generally have Flash memory, we don't actually
need a boot-loader in that sense. Instead, we implement something more like
the interface provided by an IBM PC-compatible 'legacy' BIOS for running
MS-DOS, which itself was modeled on the design of CP/M's BIOS and BDOS
components. In that case, the BIOS provides a fixed application binary
interface (ABI) which is unchanging. This allowed development of MS-DOS (and
CP/M) to be performed against a fixed target (or rather, multiple
implementations of a fixed ABI), allowing the same copy of MS-DOS or CP/M to
run on a variety of PCs from a variety of manufacturers. The alternative would
be to require all of the drivers and board support packages to be added into
OS kernel (as usually happens with Linux), or for the drivers to be loaded
from disk at boot-up (as with Windows). We have seen with Linux that, for
whatever reason, not all boards and peripherals get their driver support
upstreamed, and because Linux does not maintain a binary ABI for drivers,
anything that isn't upstream quickly becomes obsolete. As a case in point, try
to update the version of Linux used on circa-2015 Android tablet - you'll
quickly find yourself stuck on an old Kernel version with bespoke patches (or
worse, binary blobs) that weren't upstreamed or open-sourced. Whilst Windows
maintains a binary ABI for drivers, they are usually closed-source and of
varying quality, leading to system instabilities that are almost impossible to
debug.</p>
<p>The Neotron approach allows for:</p>
<ul>
<li>Less centralised development: the Neotron developers do not need to look
after (or even know about) your BIOS implementation, as long as it meets the
ABI</li>
<li>Easier upgrades: any system with a Neotron BIOS should be updateable to a
newer version of the Neotron OS</li>
<li>A smaller OS: the amount of code in the OS (e.g. for drivers) is reduced, which
means the OS is easier to understand and review</li>
<li>Simpler builds: everyone can run basically the same build of the OS (subject
to some constraints about the specific Arm architecture being targeted) as
everything board specific is in the BIOS</li>
<li>Better portability: because anything CPU specific is in the BIOS, it should
<ul>
<li>in theory - be possible to port the Neotron OS to another CPU architecture
with just a re-compile.</li>
</ul>
</li>
</ul>
<p>The downsides are:</p>
<ul>
<li>It's slower: there can be no optimisation across the OS / BIOS boundary.</li>
<li>Limited support: it's harder to add new classes of peripheral bus (e.g. if
we ever wanted to add support for I3C), as the old BIOSes won't know about
them.</li>
<li>Harder to design: a binary-stable ABI is harder to design in Rust than a
plain function-call API, as you have to use <code>extern &quot;C&quot;</code> and <code>#[repr(C)]</code>,
and therefore can't use significant portions of the Core Library in your API
definition.</li>
</ul>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>For BIOS testing, there will be a special 'cut-down' version of the OS which
offers only a very basic console, and direct access to all the BIOS APIs via
that console.</p>
<h2><a class="header" href="#character-sets" id="character-sets">Character Sets</a></h2>
<p>The video display engines on a Neotron system only support monospaced 8-bit
fonts (that is, fonts with only 256 glyphs and where each glyph occupies the
same horizontal space on screen), and so the mapped text buffer memory works
exclusively in the character set defined by the font. The rest of the BIOS API
works exclusively in UTF-8 encoded text, and mapping functions are provided by
the BIOS to convert from a Unicode codepoint to the font-specific character set.
Generally the first 128 glyphs will match basic ASCII (and hence the first 128
Unicode code points) for performance reasons, although that isn't necessarily
required.</p>
<p>It is possible that Neotron could be adapted to support multi-byte character
sets (e.g. for Chinese, Japanese or Korean text display where more than 256
glyphs are required), but there is no support for that planned at this time.</p>
<h1><a class="header" href="#the-neotron-bios---api-calls" id="the-neotron-bios---api-calls">The Neotron BIOS - API Calls</a></h1>
<p>The BIOS exports its functionality to the OS through a structure of function pointers. This structure exists in BIOS memory (probably in Flash, but it could be in RAM) and a pointer to it is passed to the Operating System (OS) when the OS is started by the BIOS.</p>
<p>The OS should only access the hardware through the function pointers contained within the given structure. The only assumption the OS can make is about the location of the memory regions defined in its Linker Script.</p>
<p>The BIOS API is documented at <a href="https://docs.rs/neotron-common-bios/latest/neotron_common_bios/">https://docs.rs/neotron-common-bios/latest/neotron_common_bios/</a>.</p>
<h1><a class="header" href="#the-neotron-os" id="the-neotron-os">The Neotron OS</a></h1>
<p>The Neotron OS is the hardware-agnosting implementation of the Neotron API. It uses the BIOS to interact with the hardware, allowing it to run on different hardware platforms with the minimum number of changes.</p>
<pre><code>+-------+-------------+
|       |             |
| Shell | Application |
|       |             |
+=======+=============+
|                     |
|  Operating System   |
|                     |
+=====================+
|                     |
|        BIOS         |
|                     |
+---------------------+
|                     |
|    Raw Hardware     |
|                     |
+---------------------+
</code></pre>
<p>It should implement:</p>
<ul>
<li>File/Device handling (open, read, write, seek, etc)</li>
<li>A FAT16/32 compatible filesystem with MS-DOS MBR partitions (max 2 TiB disk size - 2<sup>32</sup> sectors of 512 bytes)</li>
<li>A text-mode console, with cursor</li>
<li>Basic line-based input and character based raw input</li>
<li>Simple bitmap graphics primitives (lines, rectangles, fill, etc)</li>
<li>An audio synthesiser</li>
<li>Input/output stream handling</li>
<li>Digital (Atari) joystick support</li>
<li>A TCP/IP networking stack</li>
<li>MIDI support</li>
<li>Jumping to applications located in RAM or ROM, giving them access to the OS</li>
<li>Supporting special 'shell' applications which can chain-load small programs (e.g. command-line utilities) without being unloaded</li>
<li>Memory allocation/deallocation routines</li>
<li>Run-time volume mounting/unmounting</li>
</ul>
<p>Selected non-goals (i.e. things we aren't going to support) include:</p>
<ul>
<li>Co-operative multi-tasking</li>
<li>Pre-emptive multi-threading</li>
<li>Virtual Memory (although we might support a special API for paging to and from disk)</li>
<li>Processes / process isolation</li>
</ul>
<p>Our ultimate goal is that one day we could offer a version of the Rust Standard Library (<code>std</code>) which uses the Neotron OS API - albeit without the sub-process and thread support.</p>
<p>Programming on the Neotron usually involves first loading the specific interpreter for that language - unless you've swapped out the standard shell for something like a BASIC interpreter.</p>
<h2><a class="header" href="#filename-convention" id="filename-convention">Filename Convention</a></h2>
<p>Files live in volumes. Volumes on fixed or removable disks must be formatted with the FAT12, FAT16 or FAT32 filesystem and live either live in a disk partition identified by a PC Master Boot Record (with a suitable Filesystem Type), or live at the start of the drive. Volumes are allocated a volume number, starting with <code>0:</code>, then <code>1:</code> etc. File paths are relative to a volume number. Paths are separated with a <code>/</code> character. The root directory is called <code>/</code>.</p>
<p>When a volume has a name, you can refer to it as <code>&lt;name&gt;:</code> instead of <code>&lt;id&gt;:</code>. For example <code>work:/Documents/hello.txt</code> refers to a file called <code>hello.txt</code> inside a folder called <code>Documents</code> which lives on a volume called <code>work</code>.</p>
<p>It is an error to try and create a file containing a <code>:</code> character. Any files or directories which do contain invalid characters are as if the character was replaced with <code>_</code>. When a directory contains multiple files with the same name, any attempt to read the file will only be able to access the one that is found first. Any attempt to create a new file will cause any existing files of the same name in the same folder to be deleted.</p>
<p>For example:</p>
<pre><code class="language-console">0:/&gt; dir 1:
Listing files in 1:/
FOO.TXT      1234  2019-10-17 23:20:01 A--
COMMANDS.SH    34  2019-10-17 23:20:11 AR-
FOLDER       &lt;DIR&gt; 2019-09-13 20:20:11 D--

0:/&gt; dir 1:/FOLDER
Listing files in 1:/FOLDER
BAR.TXT      1234  2019-10-18 10:11:13 ---

0:/&gt; cd 1:/FOLDER

1:/FOLDER&gt; dir
Listing files in 1:/FOLDER
BAR.TXT      1234  2019-10-18 10:11:13 ---

1:/&gt;
</code></pre>
<p>Unlike MS-DOS, which has a separate <em>current directory</em> for each volume (i.e. drive letter), Neotron maintains a UNIX-like single <em>current directory</em> which includes the name of the current volume. Where a volume is given without a directory path, the root directory (<code>/</code>) is presumed.</p>
<h2><a class="header" href="#file-permissions" id="file-permissions">File Permissions</a></h2>
<p>Files can be opened as read-only (write-none), write-truncate or write-append. Because Neotron is single-tasking and non-re-entrant, there is no support for lock files or exclusive file creation, but files are locked when they are opened so they can only be opened once at any one time. Files on disk support the standard FAT16/FAT32 attributes - Archive, Read-Only, Hidden and System. Seeking uses 64-bit byte offsets, although note that FAT32 limits files to 4 GiB in size.</p>
<h2><a class="header" href="#file-operations" id="file-operations">File Operations</a></h2>
<p>A file handle, whether pointing to a file on a volume, or to a <a href="software_os.html#special-devices">Special Device</a>, generally has the following functions available. These functions broadly follow the POSIX model.</p>
<ul>
<li>
<p><code>read</code> - obtain some bytes from this handle. A <code>&amp;mut [u8]</code> is supplied, and either an integer is returned which reports how many bytes in that buffer were filled by the function call, or an error is returned. The call will wait until the buffer is full, or the timeout has been met - the timeout may be zero, some finite value, or infinite. Some files (e.g. block devices) only support reading fixed size blocks and attempts to read any other size block will give an error.</p>
</li>
<li>
<p><code>write</code> - sent some bytes to this handle. A <code>&amp;[u8]</code> is supplied, and either an integer is returned which reports how many bytes from that buffer were sent by the function call, or an error is returned. The call will wait until all the bytes have been sent, or the timeout has been met - the timeout may be zero, some finite value, or infinite.  Some files (e.g. block devices) only support writing fixed size blocks and attempts to write any other size block will give an error.</p>
</li>
<li>
<p><code>seek</code> - adjust the current pointer in the file. Files opened for reading start with the pointer at the beginning. Files opened for writing start with the pointer at the end. Some special devices are not seekable and this function will return an error. The pointer can be adjusted with a number of bytes relative to a) the current position, b) the start of the file, or c) the end of the file. Seeking beyond the end of a file on disk is not supported.  Some files (e.g. block devices) only support seeking to particular offsets (e.g. a multiple of the block size) and attempting to seek to any other offset will give an error.</p>
</li>
</ul>
<h2><a class="header" href="#special-devices" id="special-devices">Special Devices</a></h2>
<p>There are special devices which look like files, but are not. They have names which are like volumes, but contain a '$' character. It is an error to try and use a regular volume with <code>$</code> in the name. Where the device name contains an <code>x</code>, the <code>x</code> should be replaced with a single digit (e.g. 0 or 1) to identify a specific device.</p>
<ul>
<li><code>CON$:</code> - The console. You can read from here to get line-buffered text input and write here to put UTF-8 text on the screen (with ANSI code sequence support).</li>
<li><code>KBD$:</code> - The raw keyboard. You can read from here to get raw keyboard events (such as Up Arrow key, or Page Down).</li>
<li><code>TIME$:</code> - Gets/sets the system time (read/write).</li>
<li><code>GFX$:</code> - A bitmap framebuffer device.</li>
<li><code>PRNx$:</code> - A printer. Write here to send data to the printer, read to get print status.</li>
<li><code>DISCx$:</code> - An SD card or other block device (can read/write raw 512 byte blocks).</li>
<li><code>SERx$:</code> - An RS-232 serial device (read/write).</li>
<li><code>TONEx$:</code> - A tone generator device (write-only).</li>
<li><code>PCMx$:</code> - A PCM device (write for playback, read for record).</li>
<li><code>JSx$:</code> - A Joystick (read-only).</li>
</ul>
<p>Additional parameters may be specified after the <code>$</code>, separated by <code>;</code>. For example:</p>
<ul>
<li><code>SER0$bps=9600;parity=N;timeout=100:</code> - The first RS-232 serial device, at 9600 bps, with a 100 frame read/write timeout.</li>
<li><code>PCM0$channels=2;bit=8;samplerate=8000:</code> - A PCM interface configured for stereo 8kHz 8-bit.</li>
</ul>
<p>Special devices do not support filenames or paths. To access something like a network volume, the volume must be mounted and given a normal volume ID. The API for this is TBD.</p>
<h3><a class="header" href="#writing-to-con" id="writing-to-con">Writing to <code>CON$:</code></a></h3>
<p>The Console device <code>CON$:</code>, like every other file, is a bi-direction octet pipe. Unfortunately, one octet is not enough to represent the full set of characters a modern computer needs to support. Rust handles this by insisting that text (<code>&amp;str</code> string slices and <code>String</code> owned strings) is in Unicode Translation Format 8 (UTF-8). This is a mechanism by which Unicode characters (which are around 21 bits in size) can be encoded as between one and six octets. The useful property is that the first 127 Unicode characters map to a single octet, which makes it interchangeable with standard ASCII.</p>
<p>In text mode, most Neotron systems will only have one octet avilable per text cell to record which particular character being displayed in that cell, therefore placing a limit of 256 different glyphs in any given font. The font must therefore also provide a translation function which can convert from a 21-bit Unicode character to an octet for storage in the screen buffer. Typically the fonts will follow some standard 8-bit <em>code page</em>, such as <a href="https://en.wikipedia.org/wiki/Code_page_850">Code Page 850</a>, but this is not enforced and aside from some characters failing to render correctly on the screen, is invisible from an application point of view.</p>
<p>Ordinarily the OS will maintain a cursor position and any text written to the Console will be added to the screen at that position. The screen has a nominal width and height, and when the cursor gets to the end of a line it moves down to the start of the next line. The console will also handle the following special characters in the usual way:</p>
<table><thead><tr><th>ASCII Code</th><th>C Escape Sequence</th><th>Keypress</th><th>Name</th><th>Function</th></tr></thead><tbody>
<tr><td>0x07</td><td><code>\a</code></td><td>Ctrl+H</td><td>Bell</td><td>Produces a beep from the speaker</td></tr>
<tr><td>0x08</td><td><code>\b</code></td><td>Ctrl+H</td><td>Backspace</td><td>Move to one character to the left</td></tr>
<tr><td>0x09</td><td><code>\t</code></td><td>Ctrl+I</td><td>Tab</td><td>Move to next column which is a multiple of 8</td></tr>
<tr><td>0x0A</td><td><code>\n</code></td><td>Ctrl+J</td><td>Line Feed</td><td>Move to start of next line</td></tr>
<tr><td>0x0C</td><td><code>\f</code></td><td>Ctrl+L</td><td>Form Feed</td><td>Clear the screen and move to start of first line</td></tr>
<tr><td>0x0D</td><td><code>\r</code></td><td>Ctrl+M</td><td>Carriage Return</td><td>Move to start of current line</td></tr>
</tbody></table>
<p>For some text mode applications, more precise control is required over the position of the cursor, the colour of the text, and so on. This is acheived by inserting <em>ANSI Escape Sequences</em> into the octet stream. The sequences supported are a subset of those defined in <a href="https://www.ecma-international.org/publications/files/ECMA-ST/Ecma-048.pdf">ECMA-48</a>, and broadly align with those commonly used on Linux/UNIX systems, although support for the specific colours, etc, depends on the video support available in the BIOS. In the following table:</p>
<ul>
<li><code>ESC</code> means <em>Escape</em>. It is represented by the single Unicode character <code>U+001B</code> (<code>0x1B</code> in UTF-8).</li>
<li><code>CSI</code> means <em>Control Sequence Introducer</em>. It is represented by the the single Unicode character <code>U+009B</code> (or <code>0xC2 0x9B</code> in UTF-8), or alternatively the two character sequence <code>ESC [</code> (<code>0x1B 0x5B</code> in UTF-8).</li>
<li>The lowercase characters <em>n</em> and <em>m</em> represent optional integer parameters, rendered as decimal in ASCII using the characters <code>0</code> to <code>9</code>.</li>
<li>Rows and Columns are 1 indexed, with <code>1,1</code> being the top left of the screen.</li>
</ul>
<table><thead><tr><th>Sequence</th><th>Function</th></tr></thead><tbody>
<tr><td>ESC c</td><td>Reset to Intial State</td></tr>
<tr><td>CSI <em>n</em> A</td><td>Cursor Up <em>n</em> (default 1) rows</td></tr>
<tr><td>CSI <em>n</em> B</td><td>Cursor Down <em>n</em> (default 1) rows</td></tr>
<tr><td>CSI <em>n</em> C</td><td>Cursor Forward <em>n</em> (default 1) columns</td></tr>
<tr><td>CSI <em>n</em> D</td><td>Cursor Back <em>n</em> (default 1) columns</td></tr>
<tr><td>CSI <em>n</em> ; <em>m</em> H</td><td>Cursor Position to row <em>n</em> (default 1) and column <em>m</em> (default 1)</td></tr>
<tr><td>CSI <em>n</em> [ ; <em>m</em> ] m</td><td><em>Select Graphic Rendition</em> (see below for valid parameters)</td></tr>
</tbody></table>
<p>The <em>Select Graphic Rendition</em> codes are as follows. Note that multiple codes can be specified in one escape sequence, separated by semicolons. Most of the codes only affect text which is subsequently printed to the console - the only exception is the font select commands 10 to 13 which change the font for the entire screen. The loading of custom fonts is performed through a separate OS call.</p>
<table><thead><tr><th>SGR Code</th><th>Function</th></tr></thead><tbody>
<tr><td>0</td><td>All attributes off</td></tr>
<tr><td>1</td><td>Subsequent text is bold</td></tr>
<tr><td>8</td><td>Subsequent text is concealed (replaced with *)</td></tr>
<tr><td>4</td><td>Subsequent text is underlined</td></tr>
<tr><td>7</td><td>Swap foreground/background colours</td></tr>
<tr><td>10</td><td>Select default font (usually VGA Code Page 850)</td></tr>
<tr><td>11</td><td>Select alternative font 1 (usually Teletext)</td></tr>
<tr><td>12</td><td>Select alternative font 2 (user defined)</td></tr>
<tr><td>13</td><td>Select alternative font 3 (user defined)</td></tr>
<tr><td>28</td><td>Turns off conceal mode</td></tr>
<tr><td>30</td><td>Set foreground colour to Black</td></tr>
<tr><td>31</td><td>Set foreground colour to Red</td></tr>
<tr><td>32</td><td>Set foreground colour to Green</td></tr>
<tr><td>33</td><td>Set foreground colour to Yellow</td></tr>
<tr><td>34</td><td>Set foreground colour to Blue</td></tr>
<tr><td>35</td><td>Set foreground colour to Magenta</td></tr>
<tr><td>36</td><td>Set foreground colour to Cyan</td></tr>
<tr><td>37</td><td>Set foreground colour to White</td></tr>
<tr><td>40</td><td>Set background colour to Black</td></tr>
<tr><td>41</td><td>Set background colour to Red</td></tr>
<tr><td>42</td><td>Set background colour to Green</td></tr>
<tr><td>43</td><td>Set background colour to Yellow</td></tr>
<tr><td>44</td><td>Set background colour to Blue</td></tr>
<tr><td>45</td><td>Set background colour to Magenta</td></tr>
<tr><td>46</td><td>Set background colour to Cyan</td></tr>
<tr><td>47</td><td>Set background colour to White</td></tr>
</tbody></table>
<p>The Neotron application library allows access to the console via two means:</p>
<ul>
<li>Implicitly, through the use of the <code>println!</code> macro.</li>
<li>Explicitly, through the use of the Standard Output file handle, obtained with <code>neotron::io::stdout()</code> or by opening the <code>CON$:</code> device for writing.</li>
</ul>
<p>The Neotron OS doesn't have a concept of 'Standard Error' as distinct from 'Standard Output'. Application libraries may wish to emulate this feature by, for example, printing any text output by <code>eprintln!</code> in a different colour.</p>
<h3><a class="header" href="#reading-from-con" id="reading-from-con">Reading from <code>CON$:</code></a></h3>
<p>Performing a read on the console device will block the application until either the Enter key is pressed on the keyboard, or <code>Control + C</code> is pressed on the keyboard. If the Enter key is pressed, the UTF-8 encoding of the characters entered by the user are copied to the given buffer (up to as many as will fit). If too many characters are entered to fit in to the given buffer, the Console will beep and the user must use Backspace to remove some characters and free up some buffer space. Characters being entered are echoed to the console (although Conceal mode will help if the user is entering a password).</p>
<p>In the background during this function, the OS is polling the keyboard for key events, handling special keys (like Backspace, or Shift) and when a valid key is pressed, the matching Unicode character is UTF-8 encoded and added to the buffer.</p>
<p>On some Neotron systems, pressing the 'Up' arrow key will restore the previous command line contents (like when using the <code>readline</code> library on GNU/UNIX systems).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use neotron::fs::File;
let mut buffer = [0u8; 16];
/// The standard Neotron file read functions can be used to read from the console.
let mut console = File::open(&quot;CON$:&quot;)
	.expect(&quot;Failed to open console for reading&quot;);
match console.read(&amp;mut buffer) {
	Ok(0) =&gt; {
		println!(&quot;You entered an empty string&quot;);
	}
	Ok(n) =&gt; {
		// The Neotron OS guarantees this will be valid UTF-8
		let read_string = unsafe {
			core::str::from_utf8_unchecked(&amp;buffer[0..n])
		};
		println!(&quot;You entered {:?}&quot;, read_string);
	}
	Err(e) =&gt; {
		eprintln!(&quot;Oh, I got read error {:?} reading from the console&quot;, e);
	}
}
/// There is also a Neotron Application Library helper function which reads to a buffer (unlike the normal Rust Standard Library function which reads to a `String`).
let bytes_read = neotron::io::stdin()
	.read_line(&amp;mut buffer)
	.expect(&quot;Failed to read from console&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#reading-from-kbd" id="reading-from-kbd">Reading from <code>KBD$:</code></a></h3>
<p>For some applications, such as games, the application will need raw key up/down events rather than the Unicode characters those key events correspond to. For this, there is a device which returns raw key events. Reading from this device is non-blocking. Mapping is performed if the current keyboard layout is non-QWERTY (e.g. the top left letter key on an AZERTY keyboard is <code>Key::LetterA</code> not <code>Key::LetterQ</code>), but you must perform your own handling of shifted characters (for example how Shift + <code>.</code> gives you a <code>&gt;</code> character when using a United Kingdom keyboard layout). The easiest way to handle this is to allow users to map their own keys (e.g. &quot;Press the key you want to use for 'Jump': &quot;).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Key {
	LetterA,
	LetterB,
	LetterC,
	LetterD,
	...
	Digit0,
	Digit1,
	...
	Dot,
	Comma,
	PrintScreen,
	Up,
	Down,
	Left,
	Right,
	Home,
	End,
	Delete,
	...
}

struct KeyEvent(u8);

impl KeyEvent {
	unsafe fn from_octet(u8) -&gt; KeyEvent;
	fn is_keydown(&amp;self) -&gt; bool;
	fn is_keyup(&amp;self) -&gt; bool;
	fn get_key(&amp;self) -&gt; Key;
}

use neotron::fs::File;
let mut kb = File::open(&quot;KBD$:&quot;).expect(&quot;Failed to open raw keyboard&quot;);
let buffer = [0u8; 16];
/// The standard file read function is used to read from the keyboard
match kb.read(&amp;mut buffer) {
	Ok(0) =&gt; {
		println!(&quot;No raw key events available&quot;);
	}
	Ok(n) =&gt; {
		for octet in buffer[0..n].iter() {
			let ev = unsafe { KeyEvent::from_octet(octet) };
			println!(&quot;Received event {:?}&quot;, ev);
		}
	}
	Err(e) =&gt; {
		eprintln!(&quot;Oh, I got read error {:?} reading from the keyboard&quot;, e);
	}
}

<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#writing-to-kbd" id="writing-to-kbd">Writing to <code>KBD$:</code></a></h3>
<p>The least significant (1) bit of any byte written to KBD$ sets the <em>Num Lock</em> light. The next (2) bit of any byte written to KBD$ sets the <em>Caps Lock</em> light. The next (4) bit of any byte sets the <em>Scroll Lock</em> light. This is useful if you are using raw keyboard mode to handle key events and want to perform your own Num Lock, Caps Lock and Scroll Lock handling.</p>
<h3><a class="header" href="#writing-to-time" id="writing-to-time">Writing to <code>TIME$:</code></a></h3>
<p>Write an ASCII string in ISO-8601 format (e.g. <code>2020-01-01T15:44:21.031Z</code>) to set the time.</p>
<h3><a class="header" href="#reading-from-time" id="reading-from-time">Reading from <code>TIME$:</code></a></h3>
<p>Reading from this device will return an ASCII/UTF-8 string in ISO-8601 format (e.g. <code>2020-01-01T15:44:21.031Z</code>).</p>
<pre><code class="language-console"># Reading the time in the Neotron Shell with the cat command
$ cat TIME$:
2020-01-01T15:44:21.031Z
$
</code></pre>
<h3><a class="header" href="#writing-to-gfx" id="writing-to-gfx">Writing to <code>GFX$:</code></a></h3>
<p>Opening the <code>GFX$mode=X:</code> device puts the system into specified video mode <em>X</em> and gives access to the underlying video RAM. Optional <em>x</em>, <em>y</em>, <em>width</em> and <em>height</em> parameters allow a window to be created into video RAM, which is useful if you want to update a small region. Setting pixels on the screen is simply a case of seeking to the correct position and writing out as many bytes as required. The specific format of the bytes written to this device will depend on the current video mode. There is some other (TBD) mechanism obtain the list of supported video modes and their formats, but they will include Chunky modes (where multiple consecutive bits/bytes map to Red, Green and Blue components for each pixel) and Planar modes (where Red, Green and Blue each have their own distinct regions). This device is useful to blitting bitmaps to the screen, but drawing lines and circles is more efficiently performed through other OS APIs.</p>
<pre><code class="language-console"># Using the copy command in the Neotron Shell to put a picture at the top of the screen in Mode 7
$ copy 0:/EXAMPLE.GFX GFX$mode=7;height=150:
30000 bytes copied
$
</code></pre>
<h3><a class="header" href="#reading-from-gfx" id="reading-from-gfx">Reading from <code>GFX$:</code></a></h3>
<p>Reading from this device allows an application to determine what is currently on the screen. The data is in the same format as when <a href="software_os.html#writing-to-gfx">writing to the device</a>.</p>
<h3><a class="header" href="#writing-to-prnx" id="writing-to-prnx">Writing to <code>PRNx$:</code></a></h3>
<p>Ordinarily, every byte written to this device is sent to the Parallel Port, followed by high pulse on the <code>STROBE</code> pin and a busy-wait for the <code>BUSY</code> pin to return low. If any error signals are activated by the printer, the write is ended early.</p>
<p>Opening this device with the option <code>raw</code>, enables raw mode. In this mode, each write must be a two byte value:</p>
<ul>
<li>Byte 0 is 0x00 to write to the data pins or 0x01 to write to the control pins</li>
<li>Byte 1 is the value to write to all eight data pins, or to the control pins as per the following table.</li>
</ul>
<table><thead><tr><th>Bit Number</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>1 to enable STROBE (active high)</td></tr>
<tr><td>1</td><td>1 to enable LINE_FEED (active low)</td></tr>
<tr><td>2</td><td>1 to enable RESET (active high)</td></tr>
<tr><td>3</td><td>1 to enable SELECT_PRINTER (active low)</td></tr>
</tbody></table>
<p>In <code>raw</code> mode you can use the Parallel Port as a generic GPIO port with 12 output pins, and 5 <a href="software_os.html#reading-from-prn">input pins</a>.</p>
<h3><a class="header" href="#reading-from-prnx" id="reading-from-prnx">Reading from <code>PRNx$:</code></a></h3>
<p>A read will return one byte which is a bitmask of the status bits, regardless of whether it was opened in raw mode or normal mode.</p>
<table><thead><tr><th>Bit Number</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>1 when ERROR is active (low)</td></tr>
<tr><td>1</td><td>1 when SELECT_IN is active (high)</td></tr>
<tr><td>2</td><td>1 when PAPER_OUT is active (high)</td></tr>
<tr><td>3</td><td>1 when ACK is active (low)</td></tr>
<tr><td>4</td><td>1 when BUSY is active (low)</td></tr>
</tbody></table>
<h3><a class="header" href="#writing-to-discx" id="writing-to-discx">Writing to <code>DISCx$:</code></a></h3>
<p>Allows access to the raw blocks on a disk. Useful for writing out disk images. Support for creating partition tables is TBD, and may have to be done at the application level by writing to the first sector on disk. Writing to raw disk structures whilst files are open on that volume is likely to lead to filesystem corruption.</p>
<h3><a class="header" href="#reading-from-discx" id="reading-from-discx">Reading from <code>DISCx$:</code></a></h3>
<p>Allows access to the raw blocks on a disk. Useful for taking disk images, or inspecting raw disk structures. The option <code>partition=X</code> allows a specific partition to be selected, where <code>1</code> to <code>4</code> are the first four Primary partitions, and <code>5</code> or greater selects a Logical Partition located within the Extended Partition. Inspecting the partition metadata (start, end, filesystem type, etc) must be done at the application level by reading the first sector.</p>
<h3><a class="header" href="#opening-serx" id="opening-serx">Opening 'SERx$:'</a></h3>
<table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td>handshaking=rtscts</td><td>Enable RTS/CTS handshaking</td></tr>
<tr><td>handshaking=xonoff</td><td>Enable XON/XOFF handshaking</td></tr>
<tr><td>handshaking=none</td><td>Disable handshaking (default)</td></tr>
<tr><td>bps=X</td><td>Set bitrate to X bits per second</td></tr>
<tr><td>timeout=X</td><td>Set read/write timeout to X frames</td></tr>
<tr><td>timeout=none</td><td>Block forever on read/write</td></tr>
<tr><td>timeout=0</td><td>Never block on read/write</td></tr>
</tbody></table>
<h3><a class="header" href="#writing-to-serx" id="writing-to-serx">Writing to <code>SERx$:</code></a></h3>
<p>A write will block until all of the octets have been transmitted to the remote device at the specified bit rate, or a timeout occurs (if specified).</p>
<h3><a class="header" href="#reading-from-serx" id="reading-from-serx">Reading from <code>SERx$:</code></a></h3>
<p>A read will block until the given number of octets have been received from the remote device at the specified bit rate, or a timeout occurs (if specified).</p>
<h3><a class="header" href="#opening-tonex" id="opening-tonex">Opening 'TONEx$:'</a></h3>
<p>No options when opening TONE devices.</p>
<h3><a class="header" href="#writing-to-tonex" id="writing-to-tonex">Writing to <code>TONEx$:</code></a></h3>
<p>A tone is specified with three parameters:</p>
<ul>
<li>A frequency, in Hertz.</li>
<li>A waveform (e.g. Square, Sine, Triangle, White Noise, etc)</li>
<li>A volume (between 1 and 16)</li>
</ul>
<p>These three parameters are packed into four bytes:</p>
<pre><code> Byte 0        Byte 1        Byte 2        Byte 3
+-------------+-------------+-------------+-------------+
|Frequency LSB|Frequency MSB|Waveform     |Volume       |
+-------------+-------------+-------------+-------------+
</code></pre>
<p>The buffer written must be a multiple of four octets in length.</p>
<h3><a class="header" href="#reading-from-tonex" id="reading-from-tonex">Reading from <code>TONEx$:</code></a></h3>
<p>Not supported.</p>
<h3><a class="header" href="#opening-pcmx" id="opening-pcmx">Opening 'PCMx$:'</a></h3>
<table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td>channels=N</td><td>Enable <em>N</em> channels (default is 1)</td></tr>
<tr><td>bits=U8</td><td>Set 8-bit linear unsigned samples</td></tr>
<tr><td>bits=S8</td><td>Set 8-bit linear signed samples</td></tr>
<tr><td>bits=U16</td><td>Set 16-bit linear unsigned samples</td></tr>
<tr><td>bits=S16</td><td>Set 16-bit linear signed samples</td></tr>
<tr><td>rate=X</td><td>Configure for X samples per second</td></tr>
</tbody></table>
<h3><a class="header" href="#writing-to-pcmx" id="writing-to-pcmx">Writing to <code>PCMx$:</code></a></h3>
<p>When the PCM device is opened, the number of channels (mono/stereo), sample rate (e.g. 22,050 Hz), bit depth (e.g. 8 bits) are specified. The bytes written are the samples to be played, as little-endian integers. If there are multiple channels, the samples for each channel are supplied in turn before moving on to the next sample (e.g. <em>Left Sample N</em>, <em>Right Sample N</em>, <em>Left Sample N+1</em>, <em>Right Sample N+1</em>). You should write sufficiently often to avoid underflowing the internal PCM buffer.</p>
<h3><a class="header" href="#reading-from-pcmx" id="reading-from-pcmx">Reading from <code>PCMx$:</code></a></h3>
<p>When the PCM device is opened, the number of channels (mono/stereo), sample rate (e.g. 22,050 Hz), bit depth (e.g. 8 bits) are specified. The bytes read are the samples which have been recorded, as little-endian integers. If there are multiple channels, the samples for each channel are supplied in turn before moving on to the next sample (e.g. <em>Left Sample N</em>, <em>Right Sample N</em>, <em>Left Sample N+1</em>, <em>Right Sample N+1</em>). You should read sufficiently often to avoid overflowing the internal PCM buffer.</p>
<h3><a class="header" href="#writing-to-jsx" id="writing-to-jsx">Writing to <code>JSx$:</code></a></h3>
<p>Not supported</p>
<h3><a class="header" href="#reading-from-jsx" id="reading-from-jsx">Reading from <code>JSx$:</code></a></h3>
<p>Returns a bitmask of inputs from that joystick:</p>
<table><thead><tr><th>Bit Number</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>Up</td></tr>
<tr><td>1</td><td>Down</td></tr>
<tr><td>2</td><td>Left</td></tr>
<tr><td>3</td><td>Right</td></tr>
<tr><td>4</td><td>Fire 1 (B)</td></tr>
<tr><td>5</td><td>Fire 2 (C)</td></tr>
<tr><td>6</td><td>Fire 3 (A)</td></tr>
<tr><td>7</td><td>Fire 4 (Start)</td></tr>
</tbody></table>
<p>Yes, the fire buttons are in that order - mainly because on a Master System pad, you only have Fire Button 1 and Fire Button 2, but on a Mega Drive pad, those same pins on the interface correspond to Fire Buttons B and C. If you have a standard Atari/Commodore joystick, you will probably only have Fire Button 1.</p>
<p>The OS will poll the joystick once per video frame, so attempting to read more often than that will given repeated results. A fire button is very likely to be held for multiple frames, so you will need to store the previous reading and check which bits have flipped since last time.</p>
<h2><a class="header" href="#threads-and-processes" id="threads-and-processes">Threads and Processes</a></h2>
<p>The Neotron OS has no support for running multiple processes, nor for multi-threading, nor for multi-core systems. It is very much like MS-DOS and CP/M in this regard. It does, however, use locks to ensure that should the use of interrupts cause a function to be 're-entered', the situation is caught gracefully rather than leading to system instability. A user is, therefore, free to implement multi-threading within their application if they so wish.</p>
<h2><a class="header" href="#memory-allocation" id="memory-allocation">Memory Allocation</a></h2>
<p>The Neotron BIOS initialise all of the RAM, configures a stack, reserves a further portion of RAM for its own use, and passes the OS a structure which describes the start and end address of each contiguous block of remaining memory (and there may be several if your CPU has multiple separate SRAMs). From this remainder, the Neotron OS allocates what it needs for its own purposes.</p>
<p>The Neotron OS has a built-in heap memory allocation routine (like <code>malloc</code>) and matching deallocation routine (like <code>free</code>) and it offers these to the currently running application. This saves the application having to include its own memory allocation routines. When an application is loaded, the heap is automatically set to use all of the remaining un-used RAM (which varies depending on the size of the application). Applications are usually (but not always) given the same stack as the OS and the BIOS, and so it is very possible for a badly behaved application to corrupt and/or crash the entire system.</p>
<p>An application can always assume its own RAM for code and global variables starts at address <code>0x2000_0000</code>. The memory allocation routines may return an address from some other range (e.g. the AXI SRAM on an STM32H7 is at 0x2400_0000).</p>
<h2><a class="header" href="#networking" id="networking">Networking</a></h2>
<p>The TCP/IP stack offers a Berkley Sockets style API. Supported devices will include an SPI based Ethernet MAC/PHY devices (such as the Microchip ENC28J60) using <a href="https://github.com/m-labs/smoltcp">smoltcp</a>, and UART based Ethernet/WiFi/Cellular devices with on-board TCP/IP stack (such as the ESP-01).</p>
<h1><a class="header" href="#the-neotron-os---api-calls" id="the-neotron-os---api-calls">The Neotron OS - API Calls</a></h1>
<p>The OS exports its functionality to each Application through a structure of function pointers. This structure exists in OS memory (probably in Flash, but it could be in RAM) and a pointer to it is passed to the Application when it is started by the OS. This is the same process as used when the BIOS starts the OS.</p>
<p>The Application should only access the hardware and the operating system state through the function pointers contained within the given structure. The only assumption the Application can make is about the location of the memory regions defined in its Linker Script.</p>
<p>The OS API is (or will be) documented at <a href="https://github.com/Neotron-Compute/Neotron-API">https://github.com/Neotron-Compute/Neotron-API</a>.</p>
<h1><a class="header" href="#the-neotron-command-shell" id="the-neotron-command-shell">The Neotron Command Shell</a></h1>
<h2><a class="header" href="#introduction-2" id="introduction-2">Introduction</a></h2>
<p>The Neotron Shell is the first application started by the OS. It allows the user to give the system commands, including:</p>
<ul>
<li>Browsing filesystems on the SD card</li>
<li>Loading files from SD card into RAM</li>
<li>Inspecting the contents of RAM and ROM</li>
<li>Executing applications</li>
</ul>
<p>The Shell uses the standard OS API and hence is much like a normal application. The only difference is that it uses a special region of memory, allowing it to remaining running whilst it loads another application into the main program area. Once that application is started, it can use the shell's memory region as it's own - the OS will re-initialise the shell when the application exits.</p>
<p>Analogies from the PC world would include MS-DOS's <code>COMMAND.COM</code> and CP/M's CCP, but at a functional level it's more like the U-Boot Shell.</p>
<h2><a class="header" href="#shell-expansion" id="shell-expansion">Shell Expansion</a></h2>
<p>Any argument of the form <code>${VAR}</code> is replaced with the value stored in the environment variable called <code>VAR</code>.</p>
<p>Any argument containing a <code>*</code> character is taken to be a glob and is expanded to all the filenames matching that glob. Note that there are a limited number of arguments that can be given to a command, so attempts to glob more files than that number will generate an error.</p>
<h2><a class="header" href="#magic-devices" id="magic-devices">Magic Devices</a></h2>
<p>The OS supports a number of magic device filenames. The shell is unaware of this and just asks the OS to perform the specified operation on the given filenames.</p>
<h2><a class="header" href="#shell-commands" id="shell-commands">Shell Commands</a></h2>
<h3><a class="header" href="#dir-s-path" id="dir-s-path"><code>DIR [/S] [&lt;path&gt;]</code></a></h3>
<p>Performs a directory listing, either for the current drive and directory or of the given absolute or relative path.</p>
<p>The <code>/S</code> option displays directories recursively.</p>
<h3><a class="header" href="#mkdir-p-path" id="mkdir-p-path"><code>MKDIR [/P] &lt;path&gt;</code></a></h3>
<p>Creates a new directory, given either an absolute path or a relative path. Can
optionally make all the intermediate paths too.</p>
<h3><a class="header" href="#type-path" id="type-path"><code>TYPE &lt;path&gt;</code></a></h3>
<p>Displays the contents of a file, assuming it is ASCII text.</p>
<h3><a class="header" href="#hexdump-path" id="hexdump-path"><code>HEXDUMP &lt;path&gt;</code></a></h3>
<p>Displays the contents of a file as hex encoded binary.</p>
<h3><a class="header" href="#copy-s-source1-source2-dest" id="copy-s-source1-source2-dest"><code>COPY [/S] &lt;source1&gt; [&lt;source2&gt;...] &lt;dest&gt;</code></a></h3>
<p>Copies one or more files from one location to another. If one <code>sourceX</code> is
specified <code>dest</code> can be a file or a directory. If multiple <code>sourceX</code> files are
specified, <code>dest</code> must be a directory. The argument <code>/S</code> makes <code>COPY</code> look in
subdirectories recursively.</p>
<h3><a class="header" href="#rename-old-new" id="rename-old-new"><code>RENAME &lt;old&gt; &lt;new&gt;</code></a></h3>
<p>Changes the name of a file. Cannot move files between directories or drives.</p>
<h3><a class="header" href="#move-src-dest" id="move-src-dest"><code>MOVE &lt;src&gt; &lt;dest&gt;</code></a></h3>
<p>Moves a file from one directory to another. The <code>dest</code> path can be on a
different drive or in a different directory.</p>
<h3><a class="header" href="#del-path-path2" id="del-path-path2"><code>DEL &lt;path&gt; [&lt;path2&gt;...]</code></a></h3>
<p>Deletes one or more files.</p>
<h3><a class="header" href="#rmdir-path-path2" id="rmdir-path-path2"><code>RMDIR &lt;path&gt; [&lt;path2&gt;...]</code></a></h3>
<p>Deletes one or more empty directories.</p>
<h3><a class="header" href="#deltree-path-path2" id="deltree-path-path2"><code>DELTREE &lt;path&gt; [&lt;path2&gt;...]</code></a></h3>
<p>Recursively deletes one or more directories.</p>
<h3><a class="header" href="#peek-addr" id="peek-addr"><code>PEEK &lt;addr&gt;</code></a></h3>
<p>Displays the contents of ROM or RAM at the given address.</p>
<h3><a class="header" href="#poke-addr-value" id="poke-addr-value"><code>POKE &lt;addr&gt; &lt;value&gt;</code></a></h3>
<p>Writes a new value to RAM at the given address. Attempts to write to ROM are ignored.</p>
<h3><a class="header" href="#save-addr-length-file" id="save-addr-length-file"><code>SAVE &lt;addr&gt; &lt;length&gt; &lt;file&gt;</code></a></h3>
<p>Copies RAM or ROM to a file on disk.</p>
<h3><a class="header" href="#load-path" id="load-path"><code>LOAD &lt;path&gt;</code></a></h3>
<p>Copies the contents of a file on disk to RAM.</p>
<h3><a class="header" href="#exec-path" id="exec-path"><code>EXEC &lt;path&gt;</code></a></h3>
<p>Performs a LOAD of the given file, followed by a RUN. This command is implied if a command is given which matches the name of a file in the current directory, or in the system's <code>PATH</code> environment variable.</p>
<h3><a class="header" href="#run" id="run"><code>RUN</code></a></h3>
<p>Runs a program already in memory (e.g. having used <code>LOAD</code>)</p>
<h3><a class="header" href="#set-var-value" id="set-var-value"><code>SET &lt;var&gt; &lt;value&gt;</code></a></h3>
<p>Sets an environment variable to the given value. The value <code>var</code> should not include <code>${</code> or <code>}</code>.</p>
<pre><code class="language-console">$ SET PATH 0:/BIN;0:/OS/BIN
</code></pre>
<h3><a class="header" href="#echo-text" id="echo-text"><code>ECHO &lt;text&gt;</code></a></h3>
<p>Prints some text to the console.</p>
<pre><code class="language-console">$ ECHO &quot;Hello, world&quot;
</code></pre>
<h3><a class="header" href="#loadenv-path" id="loadenv-path"><code>LOADENV &lt;path&gt;</code></a></h3>
<p>Loads environment variables from a file.</p>
<pre><code class="language-console">$ LOADENV ./FILE.ENV
</code></pre>
<h3><a class="header" href="#saveenv-path" id="saveenv-path"><code>SAVEENV &lt;path&gt;</code></a></h3>
<p>Saves environment variables to a file.</p>
<pre><code class="language-console">$ SAVEENV ./FILE.ENV
</code></pre>
<h3><a class="header" href="#script-path" id="script-path"><code>SCRIPT &lt;path&gt;</code></a></h3>
<p>Runs the shell commands found in the given filename.</p>
<pre><code class="language-console">$ SCRIPT ./FILE.CMD
</code></pre>
<h3><a class="header" href="#edit-path" id="edit-path"><code>EDIT &lt;path&gt;</code></a></h3>
<p>Starts a full-screen text editor.</p>
<pre><code class="language-console">$ EDIT 1:/README.TXT
</code></pre>
<h3><a class="header" href="#dev" id="dev"><code>DEV</code></a></h3>
<p>Shows the list of devices reported by the BIOS.</p>
<h3><a class="header" href="#vol" id="vol"><code>VOL</code></a></h3>
<p>Shows the current list of volumes, by drive. Includes their volume names, format and storage capacity.</p>
<h3><a class="header" href="#scan" id="scan"><code>SCAN</code></a></h3>
<p>Re-scans the given device for volumes. Volumes which are no longer present (e.g. because the disk has been removed) are de-allocated their volume ID. New volumes are allocated new volume IDs.</p>
<h3><a class="header" href="#cd-dir" id="cd-dir"><code>CD [&lt;dir&gt;]</code></a></h3>
<p>Change the current directory. May include a volume ID, or be relative to the current volume, or the current directory. Unlike MS-DOS, there is only one current directory for the whole system (instead of one for each drive).</p>
<h3><a class="header" href="#attr-a-a--h-h--r-r--s-s--path" id="attr-a-a--h-h--r-r--s-s--path"><code>ATTR [/A] [/A-] [/H] [/H-] [/R] [/R-] [/S] [/S-] &lt;path&gt;</code></a></h3>
<p>Gets or sets a file's attributes (Archive, Hidden, Read Only, and System).</p>
<p>The <code>/X</code> flag sets a the relevant bit. The <code>/X-</code> flag unsets it.</p>
<pre><code class="language-console">$ # Set System, Hidden and Read Only, but clear Archive
$ ATTR /A- /S /H /R SYSTEM.DAT
</code></pre>
<h1><a class="header" href="#the-neotron-menu-shell" id="the-neotron-menu-shell">The Neotron Menu Shell</a></h1>
<p>In some cases, the Neotron Command Shell is a little <em>too</em> bare-bones. Perhaps the primary use of the Neotron is to play some games, or perhaps you want to browse the SD quickly using a GUI. For these situations, you can set your default shell to be the Menu Shell.</p>
<p>The Menu Shell is inspired by the boot-up menu on NextOS for the <a href="https://www.specnext.com/">Spectrum Next</a>.</p>
<p><img src="./system_next_menu.jpg" alt="The Spectrum Next NextOS boot menu" /></p>
<p>The Neotron Menu is displayed in text-mode (nominally 48x36) and offers a series of options the user can scroll between using the arrow keys on a PS/2 keyboard or a Joystick in Port 1. These options all correspond to an item in the Neotron Command Shell, and so there is no extra functionality offered by the Neotron Menu Shell - it just makes existing functionality easier to access. Note that the final item on the list exits the Neotron Menu Shell and replaces it as the current shell with the Neotron Command Shell.</p>
<ul>
<li>File Manager - allows the user to browse the list of volumes, and the files and directories on those volumes. It supports the usual Create/Move/Rename/Copy/Load/Delete operations.</li>
<li>Tiny BASIC - loads <a href="https://en.wikipedia.org/wiki/Tiny_BASIC">Tiny BASIC</a> compiled as Neotron Application.</li>
<li>6502 BASIC - loads a 6502 Emulator, which then runs Enhanced BASIC.</li>
<li>Test Video - runs through the various graphical/text video modes.</li>
<li>Test Audio - runs through the various tones that can be generated.</li>
<li>Test Parallel Port - displays the printer status, and optionally sends some ASCII text to the parallel printer port.</li>
<li>Configure Date/Time - displays the current RTC status and allows the date/time to be set.</li>
<li>Configure Keyboard - allows the keyboard to be tested, and the layout selected </li>
<li>MIDI Keyboard - allows you to use the Neotron as a synthesiser, by connecting a MIDI Keyboard to the MIDI In port.</li>
<li>Configure WiFi - allows you to browse the WiFi networks, and join a particular network.</li>
<li>Serial Terminal - allows you to exchange characters with any serial port in the system, including the RS-232 port and the WiFi interface.</li>
</ul>
<h1><a class="header" href="#neotron-applications" id="neotron-applications">Neotron Applications</a></h1>
<p>Neotron Applications are loaded into RAM and then executed. For portability, they should use the API provided by the OS, but the system implements no security features or memory-protection, so once they are running, they have complete control of the entire system.</p>
<p>Existing applications include:</p>
<ul>
<li>A text-mode Snake game</li>
<li>A 6502 emulator which runs 6502 Enhanced BASIC</li>
<li>Tiny BASIC</li>
<li>A slideshow/presentation tool</li>
<li>A simple synthesiser which plays notes according to MIDI input</li>
</ul>
<h1><a class="header" href="#neotron-hardware" id="neotron-hardware">Neotron Hardware</a></h1>
<p>The Netron OS is intended to be binary-portable across any machine with a Neotron BIOS. How that works out in practice remains to be seen, but that's the goal. As the BIOS API, example BIOS implementations and the OS itself are entirely open, anyone can build their own Neotron-compatible system, using any ARMv7-M compatible processor. However, there will naturally be value in having some commonality between Neotron systems, in order to reduce development effort.</p>
<p>Another important factor in the Neotron Hardware is that, like the software, it should be fully Open. That is, anyone should be able to pick up a Neotron System and understand it right down to the component parts (and why those component parts were chosen). It isn't sufficient to simply post some Gerbers on GitHub and call it done - any more than it would be to post some compiled firwmware binaries. Making an Open System means making a system where people are invited and encouraged to learn everything there is to know about that system.</p>
<h2><a class="header" href="#components" id="components">Components</a></h2>
<p>A Neotron System will naturally be comprised of:</p>
<ul>
<li>A microcontroller, also known as a System On Chip (SoC) - this will contain one or more Processor Cores, RAM, possibly Flash, and some internal peripherals
<ul>
<li>The processor core will be compatible with the <a href="https://static.docs.arm.com/ddi0419/d/DDI0419D_armv6m_arm.pdf">ARMv6-M ISA</a>*.</li>
</ul>
</li>
<li>External peripherals - such as UART level shifters, audio amplifiers, SD cards</li>
<li>A baseboard (tradtionally known as a <em>motherboard</em>) - a PCB which holds the SoC, the external peripherals, and any connectors</li>
</ul>
<p>* <em>The ARMv6-M ISA (as implemented by the Cortex-M0/M0+ processore cores) has fewer instructions, and so is easier to understand. However, ARMv6-M has no Compare-and-Swap Atomic instructions, meaning that sharing data between the main thread and interrupts can be more complicated in some situations. It is TBD as to whether this is too much of a burden for the OS to carry and we may need to raise the minimum to <a href="https://static.docs.arm.com/ddi0403/e/DDI0403E_B_armv7m_arm.pdf">ARMv7-M ISA</a>, i.e. a Cortex-M3 or higher.</em></p>
<h1><a class="header" href="#the-system-on-chip" id="the-system-on-chip">The System On Chip</a></h1>
<h2><a class="header" href="#picking-a-soc" id="picking-a-soc">Picking a SoC</a></h2>
<p>When it comes to picking an SoC for a new Neotron model, the following are important criteria:</p>
<h3><a class="header" href="#mandatory-must" id="mandatory-must">Mandatory (MUST):</a></h3>
<ul>
<li>Use an ARMv6-M compatible core (i.e. any Arm Cortex-M)</li>
<li>Generate digital RGB video at 25.175 MHz or 40 MHz, or some integer fraction thereof
<ul>
<li>Anything between 1-bit and 24-bits per pixel is acceptable.</li>
<li>VESA specify a 0.5% clock tolerance, so between 25.05 MHz and 25.3 MHz is OK</li>
<li>40 MHz gives you 800x600 (and hence 400x600, 200x600, etc)</li>
<li>25.175 MHz gives you 640x480 (and hence 320x480, 160x480, etc)</li>
<li>If you aren't performance sensitive (i.e. playing games), you could have off-chip video support implemented on a second processor, with a fast communications link (e.g. Quad SPI) between them</li>
<li>You can easily scan-double the output just by playing each line twice (or three times...)</li>
</ul>
</li>
<li>Have a four-wire UART, or an ARM Serial Wire Debug interface, for debug logging</li>
<li>Have at least 256 KiB of memory for BIOS / OS code (in Flash or RAM) </li>
<li>Have enough RAM to support the desired video modes (80x25 text mode is 4,000 bytes, while 800x600 @ 8bpp needs around 470 KiB)</li>
<li>Have at least 64 KiB of free application RAM (ideally 256 KiB or more)</li>
<li>Have an SPI Controller interface which can run at least 25 MHz</li>
<li>Have 7 or more chip-select output pins
<ul>
<li>If you are limited on pins, you can use a <code>74LS138</code> 3:8 decoder for the chip-selects</li>
</ul>
</li>
<li>Have 8 interrupt input pins
<ul>
<li>If you are limited on pins, you can use an <code>MCP23S17</code> to mux 16 interrupts inputs down to 1</li>
</ul>
</li>
<li>Have an I²C Controller interface which can run at 400 kHz</li>
<li>Have either an I²S audio codec interface, or stereo PWM audio output pins</li>
<li>Have a ROM bootloader which can boot from UART, USB or SD Card
<ul>
<li>This is so home-made systems do not require an ARM debug probe for initial programming</li>
</ul>
</li>
<li>Have a footprint that is easy to professionally assemble on a simple 4-layer PCB without micro-vias, i.e. one of
<ul>
<li>0.8mm+ pitch ball grid array (BGA) package</li>
<li>0.5mm+ pitch quad flip-chip package (QFP), shrink small-outline package (SSOP) or small-outline IC (SOIC)</li>
</ul>
</li>
<li>Have 3.3V I/O</li>
<li>Cost under $20 in one-off quantities</li>
<li>Be available from mainstream catalog vendors (e.g. Digikey)</li>
</ul>
<h3><a class="header" href="#desirable-should" id="desirable-should">Desirable (SHOULD)</a></h3>
<ul>
<li>Use an ARMv7-M compatible core (i.e. Arm Cortex-M3, Cortex-M4, Cortex-M7 or Cortex-M33)</li>
<li>Have at least one USB 2.0 Host or OTG port (High-Speed or Full-Speed)</li>
<li>Has a footprint that is easy (or at least possible) to hand-assemble at home:
<ul>
<li>0.8mm pitch QFP (e.g. 7x7mm QFP32)</li>
<li>1.27mm pitch SOIC</li>
</ul>
</li>
<li>Takes a 3.3V power input which is internally regulated down to the desired core voltage
<ul>
<li>Where multiple rails are required, we either need relaxed requirements in sequencing, or an available PMIC chip which brings the rails up in the right order</li>
</ul>
</li>
<li>Be available from the JLCPCB Parts Catalog</li>
<li>Supports additional external RAM (either SRAM, SDRAM or QSPI HyperRAM)</li>
</ul>
<p>We've identified the following parts as meeting some or more of the above criteria:</p>
<table><thead><tr><th align="left">Manuf.</th><th align="left">Part Number</th><th align="left">Core</th><th align="left">Clock (MHz)</th><th align="left">Package</th><th align="left">RAM (K)</th><th align="left">Flash (K)</th><th align="left">Price (10 off)</th><th align="left">Notes</th></tr></thead><tbody>
<tr><td align="left">ST</td><td align="left">STM32L552ZET6</td><td align="left">Cortex-M33</td><td align="left">110</td><td align="left">LQFP 144</td><td align="left">256</td><td align="left">512</td><td align="left">£6.65</td><td align="left">Supports HyperRAM, and TrustZone, and is low-cost</td></tr>
<tr><td align="left">ST</td><td align="left">STM32H730ZBT6</td><td align="left">Cortex-M7</td><td align="left">550</td><td align="left">LQFP 144</td><td align="left">564</td><td align="left">128</td><td align="left">£6.97</td><td align="left">Great value due to small Flash. SPI SRAM support.</td></tr>
<tr><td align="left">ST</td><td align="left">STM32H7A3ZIT6</td><td align="left">Cortex-M7</td><td align="left">280</td><td align="left">LQFP 144</td><td align="left">1344</td><td align="left">2048</td><td align="left">£11.00</td><td align="left">Big SRAM - might not need external RAM?</td></tr>
<tr><td align="left">ST</td><td align="left">STM32H743ZGT6</td><td align="left">Cortex-M7</td><td align="left">480</td><td align="left">LQFP 144</td><td align="left">1024</td><td align="left">1024</td><td align="left">£13.75</td><td align="left">Cheapest H7 with 1 MiB SARM. No SPI SRAM support - will require SDRAM</td></tr>
<tr><td align="left">TI</td><td align="left">TM4C1299KCZADI3</td><td align="left">Cortex-M4</td><td align="left">120</td><td align="left">VFBGA 212</td><td align="left">256</td><td align="left">512</td><td align="left">£11.78</td><td align="left">Poor value, but same family as Neotron-32</td></tr>
<tr><td align="left">NXP</td><td align="left">IMXRT1062DVJ6A</td><td align="left">Cortex-M7</td><td align="left">600</td><td align="left">BGA 196</td><td align="left">1024</td><td align="left">External</td><td align="left">£10.41</td><td align="left">As used on Teensy 4.1. HyperRAM support.</td></tr>
<tr><td align="left">Raspberry Pi</td><td align="left">RP2040</td><td align="left">2x Cortex-M0+</td><td align="left">133 MHz</td><td align="left">QFN 56</td><td align="left">256</td><td align="left">External</td><td align="left">£0.85</td><td align="left">Incredibly cheap. Cortex-M0 only supports ARMv6-M. No RAM upgrades</td></tr>
</tbody></table>
<p>It is worth also considering the Lattice range of small, low-cost FPGAs, and loading an RISC-V soft-core like the VexRiscv.</p>
<h1><a class="header" href="#video-from-a-system-on-chip" id="video-from-a-system-on-chip">Video from a System On Chip</a></h1>
<p>Video support from your SoC can vary greatly - from SoCs which basically have no video support but can be 'tricked' into generating a signal that's sort-of VGA compatible, to SoCs which have on-board graphics accelerators that can render multiple semi-transparent planes together.</p>
<h2><a class="header" href="#video-modes" id="video-modes">Video Modes</a></h2>
<p>First, we should discuss the concept of a <em>video mode</em>. This is a collection of parameters which describe the picture that is being generated.</p>
<h3><a class="header" href="#timing" id="timing">Timing</a></h3>
<p>In this section, we generally assume that the video is VGA-like - that is, each frame is drawn line-by-line, starting with the top line and moving downwards. A line comprises pixels, which are drawn from left to right. Each pixel has a colour, which can be anywhere between 'on or off' or 'one of 16.8 million colours'. As the pixels are drawn left to right, there will be some extra non-visible 'off-screen' pixels, which are designed to give an old-fashioned cathode-ray tube (CRT) monitor time to move the scanning 'gun' back over to the left hand side of the image ready to draw the next line. In the same fashion, there will be some non-visible 'off-screen' lines which give a CRT's gun time to move back to the top of the frame. Although we almost universally use LCD monitors now, the standards still include these 'blanking periods'.</p>
<p>The monitor is able to find the visible picture within the signal, thanks to the provision of two extra signals - <em>Horizontal Sync</em> and <em>Vertical Sync</em>. These pulse high (or low) during the middle of the relevant blanking period.</p>
<p>The relevant parameters are:</p>
<ul>
<li>Horizontal Visible Pixels - the number of visible pixels on each line</li>
<li>Horizontal Front Porch - the number of non-visible pixels before the sync pulse</li>
<li>Horizontal Sync Width - the number of non-visible pixels during the sync pulse</li>
<li>Horizontal Back Porch - the number of non-visible pixels after the sync pulse</li>
<li>Horizontal Pixels - the total number of pixels on each line</li>
<li>Horizontal Scan Rate - the number of lines (visible or non-visible) drawn per second</li>
<li>Vertical Visible Lines - the number of visible lines in each frame</li>
<li>Vertical Front Porch - the number of non-visible lines before the sync pulse</li>
<li>Vertical Sync Width - the number of non-visible lines during the sync pulse</li>
<li>Vertical Back Porch - the number of non-visible lines after the sync pulse</li>
<li>Vertical Lines - the total number of lines in each frame</li>
<li>Frame Rate (or Refresh Rate, or Vertical Scan Rate) - the number of complete frames drawn per second</li>
<li>Pixel Clock (or Dot Clock) - the number of pixels (visible or non-visible - we'll get to that shortly) produced per second</li>
</ul>
<p>These terms are related as follows:</p>
<pre><code>Horizontal Pixels = Horizontal Visible Pixels + Horizontal Front Porch + Horizontal Sync Width 
+ Horizontal Back Porch
Vertical Lines = Vertical Visible Lines + Vertical Front Porch + Vertical Sync Width 
+ Vertical Back Porch
Horizontal Scan Rate = Pixel Clock / Horizontal Pixels
Frame Rate = Horizontal Scan Rate / Vertical Lines
</code></pre>
<p>Your monitor will place limits on the values for Frame Rate, Horizontal Scan Rate and Vertical Lines. An analog CRT generally doesn't care about Horizontal Pixels and Pixel Clock - provided the Horizontal Scan Rate is within range - although if you push this beyond the maximum bandwidth of you display (or your cable) the signal starts to get 'smoothed' and the greater definition is lost. A digital display, like an LCD monitor, will sample the analog horizontal signal at fixed intervals and if your source doesn't match perfectly, you may get a fuzzy picture. Generally, the number of horizontal pixels your monitor is looking for is a function of the number of vertical lines, calculated from some look-up table of common video standards.</p>
<h3><a class="header" href="#colours" id="colours">Colours</a></h3>
<p>The monitor generally doesn't care about the number of colours each pixel can take, as the pixels are transmitted as analog red, green and blue signals (0.7V peak). However, the SoC will care as the pixels must be stored digital and the more bits per pixel, the more bytes of framebuffer RAM we require!</p>
<h3><a class="header" href="#standards" id="standards">Standards</a></h3>
<p>The original IBM standard for the <em>Video Graphics Array</em> included the following video modes:</p>
<table><thead><tr><th align="left">H. Vis</th><th align="left">V. Vis</th><th align="left">H. Tot</th><th align="left">V. Tot</th><th align="left">H. Freq</th><th align="left">Frame Rate</th><th align="left">Pixel Clock</th><th align="left">Used for</th></tr></thead><tbody>
<tr><td align="left">720</td><td align="left">400</td><td align="left">900</td><td align="left">449</td><td align="left">31.469 kHz</td><td align="left">70 Hz</td><td align="left">28.322 MHz</td><td align="left">Default 80x25 Text mode</td></tr>
<tr><td align="left">640</td><td align="left">480</td><td align="left">800</td><td align="left">525</td><td align="left">31.469 kHz</td><td align="left">60 Hz</td><td align="left">25.175 MHz</td><td align="left">High-res graphics mode</td></tr>
<tr><td align="left">640</td><td align="left">400</td><td align="left">800</td><td align="left">449</td><td align="left">31.469 kHz</td><td align="left">70 Hz</td><td align="left">25.175 MHz</td><td align="left">80x25 text with mixed graphics</td></tr>
<tr><td align="left">720</td><td align="left">350</td><td align="left">900</td><td align="left">449</td><td align="left">31.469 kHz</td><td align="left">70 Hz</td><td align="left">28.322 MHz</td><td align="left">MDA compatible text mode (720x400 with extra blanking)</td></tr>
<tr><td align="left">640</td><td align="left">350</td><td align="left">800</td><td align="left">449</td><td align="left">31.469 kHz</td><td align="left">70 Hz</td><td align="left">25.175 MHz</td><td align="left">EGA compatible text/graphics (640x400 with extra blanking)</td></tr>
<tr><td align="left">640</td><td align="left">200 (2x)</td><td align="left">800</td><td align="left">449</td><td align="left">31.469 kHz</td><td align="left">70 Hz</td><td align="left">25.175 MHz</td><td align="left">CGA compatible text/graphics mode</td></tr>
<tr><td align="left">320</td><td align="left">240 (2x)</td><td align="left">400</td><td align="left">525</td><td align="left">31.469 kHz</td><td align="left">60 Hz</td><td align="left">25.175 MHz</td><td align="left">Low-res, high-colour mode</td></tr>
<tr><td align="left">320</td><td align="left">200 (2x)</td><td align="left">400</td><td align="left">449</td><td align="left">31.469 kHz</td><td align="left">70 Hz</td><td align="left">25.175 MHz</td><td align="left">CGA compatible text/graphics graphics mode</td></tr>
</tbody></table>
<p>We see from this table that there are only two values for the Vertical Total Lines - 525 for 480-line modes and 449 for 350/400-line modes - corresponding to frame rates of 60 Hz and 70 Hz respectively. There is also the option to increase the pixel clock up from 25.175 MHz to 28.322 MHz, increasing the number of pixels per line from 800 to 900. This, in turn, increases the number of pixels per character on an 80-column text mode display from 8 to 9. Finally, we can simply halve the pixel clock to lower the horizontal resolution, which saves video memory and allows for more colours on screen.</p>
<p>The rates marked <em>(2x)</em> simply have each line drawn twice by the VGA card, in order to keep the Horizontal Frequency at the standard value.</p>
<p>During the 1990s, the resolutions and colour depths supported by video cards increased greatly, and monitors began to support a wider range of horizontal frequencies. These various modes were standardised by the Video Electronics Standards Association (<em>VESA</em>), and there are too many to list here. However, some modes of note include:</p>
<table><thead><tr><th align="left">H. Visible</th><th align="left">V. Visible</th><th align="left">H. Total</th><th align="left">V. Total</th><th align="left">H. Freq</th><th align="left">Frame Rate</th><th align="left">Pixel Clock</th></tr></thead><tbody>
<tr><td align="left">800</td><td align="left">600</td><td align="left">1056</td><td align="left">628</td><td align="left">37.9 kHz</td><td align="left">60 Hz</td><td align="left">40.0 MHz</td></tr>
<tr><td align="left">1024</td><td align="left">768</td><td align="left">1344</td><td align="left">806</td><td align="left">48.4 kHz</td><td align="left">60 Hz</td><td align="left">65.0 MHz</td></tr>
<tr><td align="left">1280</td><td align="left">720</td><td align="left">1664</td><td align="left">748</td><td align="left">44.8 kHz</td><td align="left">60 Hz</td><td align="left">74.5 MHz</td></tr>
<tr><td align="left">1920</td><td align="left">1080</td><td align="left">2576</td><td align="left">1120</td><td align="left">67.2 kHz</td><td align="left">60 Hz</td><td align="left">173.000 MHz</td></tr>
</tbody></table>
<p>We don't really think much of 1080p (1920x1080) video these days - often preferring QuadHD (2560x1440) or 4K (3840x2880) for our desktop PC monitors. These tables show, however, that even 1080p is a staggering amount of data for an SoC to generate - especially without any built-in hardware acceleration. The higher resolution modes also consume vast amounts of framebuffer RAM - 1080p in 24-bit True Colour (usually stored as 32-bits per pixel) needs 8100 KiB of RAM, just for a single frame!</p>
<h2><a class="header" href="#video-hardware" id="video-hardware">Video Hardware</a></h2>
<p>If we want to generate a VGA compatible signal, we have several options:</p>
<h3><a class="header" href="#misuse-the-wrong-peripheral" id="misuse-the-wrong-peripheral">Misuse the wrong peripheral</a></h3>
<p>We can generate pixels on basically any SoC peripheral which has a synchronous (clock-driven) output. Even a basic SPI peripheral can be used, which will generate a 1 bit-per-pixel (black and white) video signal. The Monotron project used three SPI periperals on a TM4C to produce a 3-bit-per-pixel (8 colour) signal, and with a 20 MHz pixel clock to generate a 400x600 image (like 800x600 but with half as many pixels across, and each pixel twice as wide). Various projects for the Espressif ESP32 have used the I²S interface to push out up to 14 pixels per clock cycle (16,384 colour).</p>
<p>The Raspberry Pi Pico takes peripheral abuse even further, by driving a DC-balanced 251.75 MHz TMDS (transition minimised differential signallling) signal out of some standard GPIO pins using a high-speed FIFO, some pre-calculation and some serious over-clocking. This signal is almost exactly like DVI-D video, which thanks to backwards compatibility, can be sent over an HDMI cable to any HDMI or DVI-D compatible display.</p>
<h3><a class="header" href="#use-a-tft-lcd-controller-peripheral" id="use-a-tft-lcd-controller-peripheral">Use a TFT-LCD Controller Peripheral</a></h3>
<p>Many SoCs include hardware for driving an RGB TFT LCD panel. The good news is that these RGB panels are designed to look just like a VGA monitor (but with digital bits for each pixel rather than three analog signals), and these controllers can often be programmed to generate VGA compatible signals.</p>
<p>Look for the LTDC (LCD TFT Display Controller) on the STM32 line, for example.</p>
<h3><a class="header" href="#use-an-mipi-dsi-controller-peripheral" id="use-an-mipi-dsi-controller-peripheral">Use an MIPI DSI Controller Peripheral</a></h3>
<p>MIPI DSI (Mobile Industry Processor Interface Display Serial Interface) is a standard for pushing pixels into a display using a high-speed serial interface. This reduces pin-count and electronic magnetic interference, compared to waggling the 26 individual signal lines required to send 24-bit-per-pixel digital video. DSI is often sent over flexible ribbon cable, you can see a DSI port on most Raspberry Pi boards.</p>
<p>You can get chips which will take in a DSI signal and output HDMI, such as the <a href="https://www.analog.com/en/products/adv7533.html">Analog Devices ADV7533</a> but implementing an proper 'HDMI' output will require licensing and for this reason the chips are often only available under NDA.</p>
<h3><a class="header" href="#use-an-off-chip-video-controller" id="use-an-off-chip-video-controller">Use an off-chip video controller</a></h3>
<p>If there really is nothing suitable, you can always get a second SoC or dedicated video controller to drive your display. Such chips are popular for driving LCD panels (e.g. the ILI9341 or the ST7920) but can sometimes be configured to generate VGA compatible signals.</p>
<h2><a class="header" href="#text-vs-graphics" id="text-vs-graphics">Text vs Graphics</a></h2>
<p>Neotron's video support is based broadly on that of the IBM PC <em>Video Graphics Array</em>. In the previous section, we discussed the physical attributes of the analog video signal generated by a <em>VGA</em> card. What we didn't cover, is how we generate that signal based on the contents of Video RAM (VRAM).</p>
<p>Broadly, the IBM PC has two kinds of video modes - text mode and graphics mode. Text mode is what MS-DOS would boot up in, and Graphics mode (also known in Linux as <em>framebuffer mode</em>) is what Windows 3.1 or a game like Doom would switch to. Whilst some systems (in particular 1990s RISC workstations, and modern ARM systems) have no concept of a 'text mode' and instead draw text to a graphical framebuffer, we retain the two distinct types of mode in Neotron in order to save on VRAM.</p>
<h3><a class="header" href="#text-modes" id="text-modes">Text Modes</a></h3>
<p>Text modes divide the screen into a rectangular grid of <em>cells</em>. Each <em>cell</em> contains a <em>character</em> and a set of <em>attributes</em> (such as the <em>foreground</em> and <em>background</em> colour for that cel). Each <em>character</em> is represented by a image, known as a <em>glyph</em>. All of the <em>glyphs</em> in a given <em>font</em> have the same width and height in pixels, and they each use precisely two colours - <em>foreground</em> and <em>background</em>. The specific value of <em>foreground</em> and <em>background</em> can be set for each <em>cell</em> on the screen, meaning that each <em>cell</em> takes up two bytes: one for the <em>character</em>, and one for the attributes. As the raster beam moves across the display, the video card will fetch the <em>character</em> for that <em>cell</em> from VRAM, then load the corresponding <em>glyph</em> from the <em>font</em> (which may be in VRAM, or it may be in the card's ROM). The appropriate horizontal slice is taken from the <em>glyph</em>, which is then converted to a sequence of coloured pixels by applying the <em>foreground</em> and <em>background</em> colour for that <em>cell</em>. These coloured pixels are then transmitted to the monitor in real-time.</p>
<p>Typically (and certainly in VGA text modes), each <em>character</em> is an 8-bit value, and so there can only be 256 <em>glyphs</em> in a <em>font</em>. Merging multiple <em>characters</em> into a single <em>glyph</em> (as you might do in Unicode with a <code>U+0041 LATIN CAPITAL LETTER A</code> followed by a <code>U+02CA MODIFIER LETTER ACUTE ACCENT</code> to produce an <code>Á</code>) is generally not supported, although a swap for a single <em>character</em> could be performed by the OS when the string was first written to the VRAM if the current font had a suitable <em>glyph</em> available.</p>
<p>The two main text mode resolutions for VGA are 80 columns by 25 rows, and 80 columns by 50 rows (plus some others that are much less common). The video output resolutions these correspond to depend on the <em>glyph</em> size, as follows:</p>
<table><thead><tr><th align="left">Columns x Rows</th><th align="left">Glyph Width</th><th align="left">Glyph Height</th><th align="left">Horizontal Pixels</th><th align="left">Vertical Pixels</th><th align="left">Standard</th></tr></thead><tbody>
<tr><td align="left">80 x 25</td><td align="left">9</td><td align="left">14</td><td align="left">720</td><td align="left">350</td><td align="left">MDA, Hercules</td></tr>
<tr><td align="left">40 x 25</td><td align="left">8</td><td align="left">8</td><td align="left">320</td><td align="left">200</td><td align="left">CGA, EGA</td></tr>
<tr><td align="left">80 x 25</td><td align="left">8</td><td align="left">8</td><td align="left">640</td><td align="left">200</td><td align="left">CGA, EGA</td></tr>
<tr><td align="left">80 x 25</td><td align="left">8</td><td align="left">14</td><td align="left">640</td><td align="left">350</td><td align="left">EGA</td></tr>
<tr><td align="left">80 x 43</td><td align="left">8</td><td align="left">8</td><td align="left">640</td><td align="left">350</td><td align="left">EGA</td></tr>
<tr><td align="left">80 x 25</td><td align="left">9</td><td align="left">16</td><td align="left">720</td><td align="left">400</td><td align="left">VGA</td></tr>
<tr><td align="left">80 x 50</td><td align="left">9</td><td align="left">8</td><td align="left">720</td><td align="left">400</td><td align="left">VGA</td></tr>
<tr><td align="left">80 x 30</td><td align="left">8</td><td align="left">16</td><td align="left">640</td><td align="left">480</td><td align="left">VGA</td></tr>
<tr><td align="left">80 x 60</td><td align="left">8</td><td align="left">8</td><td align="left">640</td><td align="left">480</td><td align="left">VGA</td></tr>
</tbody></table>
<p>Because a Neotron system might support other video resolutions (e.g. the native 400x300 of a Neotron 32), there is no prescriptive list of Neotron text modes. Instead, there is a BIOS API to query which modes are supported, and the width in columns and height in rows of each mode. It is assumed that each mode supports 16 foreground colours and 8 background colours, just like VGA, and that memory is arranged in a linear array of 16-bit values, where the first (lower) 8-bits identify the character and the second (higher) 8-bits identify the foreground and background colour.</p>
<pre><code>+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|             Attribute           |           Character           |
+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|  7  | 6 | 5 | 4 | 3 | 2 | 1 | 0 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
|Blink| Backgr'nd |  Foreground   |           Code Point          |
+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
</code></pre>
<p>(Diagram courtesy <a href="https://en.wikipedia.org/wiki/VGA_text_mode">https://en.wikipedia.org/wiki/VGA_text_mode</a>)</p>
<p>The <code>Blink</code> bit causes the text to alternate between being drawn normally, and being drawn entirely in the background colour (thus rendering it invisible).</p>
<p>Where the graphics are drawn by an off-chip GPU, the Neotron BIOS will need to arrange for the on-chip VRAM to be copied to the off-chip GPU during the vertical blanking interval of each frame. A text mode with 80 x 50 characters will require 4000 bytes of VRAM, which at 70 Hz needs a link of just over 41 Mbit/sec in order for the copy to complete during the blanking interval. If you are prepared to 'chase the beam' you can run a little slower. 80x25 video modes will require half that, and using run-length encoding will likely reduce it further (especially as consecutive cells are usually the same colour).</p>
<h2><a class="header" href="#support-in-neotron" id="support-in-neotron">Support in Neotron</a></h2>
<p>To keep things simple, Neotron has an 8-bit video mode value, four components. This means that an application can simply ask for 'Mode 0x25' instead of having to scan through a list of obscure modes to find out which one is closest.</p>
<pre><code>+---------+-----------+----------+-----------+
| Vert 2x |   Timing  | Horiz 2x |   Format  |
+---------+-----------+----------+---+---+---+
|    7    | 6 | 5 | 4 |    3     | 2 | 1 | 0 |
+---------+-----------+----------+---+---+---+
</code></pre>
<p>If <code>Vert 2x</code> is set, each output scan-line is drawn twice, which halves the number of rows in memory (of text or pixels).</p>
<p>If <code>Horiz 2x</code> is set, each pixel is drawn twice, which halves the number of columns in memory (of text or pixels).</p>
<p>The Timing table is:</p>
<table><thead><tr><th align="left">Mode</th><th align="left">Visible</th><th align="left">Total</th><th align="left">Pixel Clock</th><th align="left">Horizontal Scan Rate</th><th align="left">Frame Rate</th></tr></thead><tbody>
<tr><td align="left">0</td><td align="left">640 x 480</td><td align="left">800 x 525</td><td align="left">25.175 MHz</td><td align="left">31.5 kHz</td><td align="left">60 Hz</td></tr>
<tr><td align="left">1</td><td align="left">640 x 400</td><td align="left">800 x 449</td><td align="left">25.175 MHz</td><td align="left">31.5 kHz</td><td align="left">70 Hz</td></tr>
<tr><td align="left">2</td><td align="left">800 x 600</td><td align="left">1056 x 628</td><td align="left">40.000 MHz</td><td align="left">37.9 kHz</td><td align="left">60 Hz</td></tr>
<tr><td align="left">4..7</td><td align="left">TBD</td><td align="left">TBD</td><td align="left">TBD</td><td align="left">TBD</td><td align="left">TBD</td></tr>
</tbody></table>
<p>The Format table is:</p>
<table><thead><tr><th align="left">Mode</th><th align="left">Text/Graphics</th><th align="left">Font Size</th><th align="left">Colour Depth</th></tr></thead><tbody>
<tr><td align="left">0</td><td align="left">Text</td><td align="left">8 x 16</td><td align="left">16/8 Indexed</td></tr>
<tr><td align="left">1</td><td align="left">Text</td><td align="left">8 x 8</td><td align="left">16/8 Indexed</td></tr>
<tr><td align="left">2</td><td align="left">Graphics</td><td align="left">N/A</td><td align="left">32/24-bpp</td></tr>
<tr><td align="left">3</td><td align="left">Graphics</td><td align="left">N/A</td><td align="left">16-bpp</td></tr>
<tr><td align="left">4</td><td align="left">Graphics</td><td align="left">N/A</td><td align="left">8-bpp Indexed</td></tr>
<tr><td align="left">5</td><td align="left">Graphics</td><td align="left">N/A</td><td align="left">4-bpp Indexed</td></tr>
<tr><td align="left">6</td><td align="left">Graphics</td><td align="left">N/A</td><td align="left">2-bpp Indexed</td></tr>
<tr><td align="left">7</td><td align="left">Graphics</td><td align="left">N/A</td><td align="left">1-bpp Indexed</td></tr>
</tbody></table>
<p>The values marked <code>Indexed</code> have their colours translated with a 256-entry colour palette that converts from the indexed value up to a true-colour 24-bit value. These true-colour values may be truncated when output by the video card's DAC. The <code>32/24-bpp</code> entry stores 24-bit colours in a 32-bit memory location, for efficiency of access. We assume no Neotron system will ever have better than 24-bit video output!</p>
<h3><a class="header" href="#example-modes" id="example-modes">Example Modes</a></h3>
<ul>
<li>0x05: 640 x 480 graphics @ 60 Hz, with 16 colours (4-bpp)</li>
<li>0x10: 80 x 25 text mode, with 400 lines at 70 Hz</li>
<li>0x01: 80 x 60 text mode, with 480 lines at 60 Hz</li>
<li>0x9C: 320 x 200 graphics @ 70 Hz, with 256 colours (8-bpp)</li>
</ul>
<p>These example screen-shots were generated using https://int10h.org/oldschool-pc-fonts/fontlist/:</p>
<p>80x25 text with an 8x8 font (640x200), like an IBM PC-compatible with CGA:</p>
<p><img src="./640x200_text.png" alt="Mode 0x91" /></p>
<p>80x25 text with an 8x16 font (640x400), like an IBM PC-compatible with MCGA (or VGA in 8x16 mode, instead of the usual 9x16):</p>
<p><img src="./640x400_text.png" alt="Mode 0x10" /></p>
<p>40x25 text with an 8x8 font (320x200), like an IBM PC-compatible with CGA in multi-colour mode:</p>
<p><img src="./320x200_text.png" alt="Mode 0x99" /></p>
<h3><a class="header" href="#complete-mode-list" id="complete-mode-list">Complete Mode List</a></h3>
<p>For completeness, here is every one of the currently defined video modes. More will be added as further <em>Timing Mode</em> values are defined.</p>
<table><thead><tr><th align="left">Mode</th><th align="left">Timing</th><th align="left">V2x</th><th align="left">H2x</th><th align="left">Description</th><th align="right">VRAM (bytes)</th></tr></thead><tbody>
<tr><td align="left">0x00</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">0</td><td align="left">80x30 text</td><td align="right">4,800</td></tr>
<tr><td align="left">0x01</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">0</td><td align="left">80x60 text</td><td align="right">9,600</td></tr>
<tr><td align="left">0x02</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">0</td><td align="left">640x480 True-colour</td><td align="right">1,228,800</td></tr>
<tr><td align="left">0x03</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">0</td><td align="left">640x480 High-colour</td><td align="right">614,400</td></tr>
<tr><td align="left">0x04</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">0</td><td align="left">640x480 256-colour</td><td align="right">307,200</td></tr>
<tr><td align="left">0x05</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">0</td><td align="left">640x480 16-colour</td><td align="right">153,600</td></tr>
<tr><td align="left">0x06</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">0</td><td align="left">640x480 4-colour</td><td align="right">76,800</td></tr>
<tr><td align="left">0x07</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">0</td><td align="left">640x480 2-colour</td><td align="right">38,400</td></tr>
<tr><td align="left">0x10</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">0</td><td align="left">80x25 text</td><td align="right">4,000</td></tr>
<tr><td align="left">0x11</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">0</td><td align="left">80x50 text</td><td align="right">8,000</td></tr>
<tr><td align="left">0x12</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">0</td><td align="left">640x400 True-colour</td><td align="right">1,024,000</td></tr>
<tr><td align="left">0x13</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">0</td><td align="left">640x400 High-colour</td><td align="right">512,000</td></tr>
<tr><td align="left">0x14</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">0</td><td align="left">640x400 256-colour</td><td align="right">256,000</td></tr>
<tr><td align="left">0x15</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">0</td><td align="left">640x400 16-colour</td><td align="right">128,000</td></tr>
<tr><td align="left">0x16</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">0</td><td align="left">640x400 4-colour</td><td align="right">64,000</td></tr>
<tr><td align="left">0x17</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">0</td><td align="left">640x400 2-colour</td><td align="right">32,000</td></tr>
<tr><td align="left">0x20</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">0</td><td align="left">100x37 text</td><td align="right">7,400</td></tr>
<tr><td align="left">0x21</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">0</td><td align="left">100x75 text</td><td align="right">15,000</td></tr>
<tr><td align="left">0x22</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">0</td><td align="left">800x600 True-colour</td><td align="right">1,920,000</td></tr>
<tr><td align="left">0x23</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">0</td><td align="left">800x600 High-colour</td><td align="right">960,000</td></tr>
<tr><td align="left">0x24</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">0</td><td align="left">800x600 256-colour</td><td align="right">480,000</td></tr>
<tr><td align="left">0x25</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">0</td><td align="left">800x600 16-colour</td><td align="right">240,000</td></tr>
<tr><td align="left">0x26</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">0</td><td align="left">800x600 4-colour</td><td align="right">120,000</td></tr>
<tr><td align="left">0x27</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">0</td><td align="left">800x600 2-colour</td><td align="right">60,000</td></tr>
<tr><td align="left">0x80</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">0</td><td align="left">80x15 text</td><td align="right">2,400</td></tr>
<tr><td align="left">0x81</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">0</td><td align="left">80x30 text</td><td align="right">4,800</td></tr>
<tr><td align="left">0x82</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">0</td><td align="left">640x240 True-colour</td><td align="right">614,400</td></tr>
<tr><td align="left">0x83</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">0</td><td align="left">640x240 High-colour</td><td align="right">307,200</td></tr>
<tr><td align="left">0x84</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">0</td><td align="left">640x240 256-colour</td><td align="right">153,600</td></tr>
<tr><td align="left">0x85</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">0</td><td align="left">640x240 16-colour</td><td align="right">76,800</td></tr>
<tr><td align="left">0x86</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">0</td><td align="left">640x240 4-colour</td><td align="right">38,400</td></tr>
<tr><td align="left">0x87</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">0</td><td align="left">640x240 2-colour</td><td align="right">19,200</td></tr>
<tr><td align="left">0x90</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">0</td><td align="left">80x12 text</td><td align="right">1,920</td></tr>
<tr><td align="left">0x91</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">0</td><td align="left">80x25 text</td><td align="right">4,000</td></tr>
<tr><td align="left">0x92</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">0</td><td align="left">640x200 True-colour</td><td align="right">512,000</td></tr>
<tr><td align="left">0x93</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">0</td><td align="left">640x200 High-colour</td><td align="right">256,000</td></tr>
<tr><td align="left">0x94</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">0</td><td align="left">640x200 256-colour</td><td align="right">128,000</td></tr>
<tr><td align="left">0x95</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">0</td><td align="left">640x200 16-colour</td><td align="right">64,000</td></tr>
<tr><td align="left">0x96</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">0</td><td align="left">640x200 4-colour</td><td align="right">32,000</td></tr>
<tr><td align="left">0x97</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">0</td><td align="left">640x200 2-colour</td><td align="right">16,000</td></tr>
<tr><td align="left">0xA0</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">0</td><td align="left">100x18 text</td><td align="right">3,600</td></tr>
<tr><td align="left">0xA1</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">0</td><td align="left">100x37 text</td><td align="right">7,400</td></tr>
<tr><td align="left">0xA2</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">0</td><td align="left">800x300 True-colour</td><td align="right">960,000</td></tr>
<tr><td align="left">0xA3</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">0</td><td align="left">800x300 High-colour</td><td align="right">480,000</td></tr>
<tr><td align="left">0xA4</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">0</td><td align="left">800x300 256-colour</td><td align="right">240,000</td></tr>
<tr><td align="left">0xA5</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">0</td><td align="left">800x300 16-colour</td><td align="right">120,000</td></tr>
<tr><td align="left">0xA6</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">0</td><td align="left">800x300 4-colour</td><td align="right">60,000</td></tr>
<tr><td align="left">0xA7</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">0</td><td align="left">800x300 2-colour</td><td align="right">30,000</td></tr>
<tr><td align="left">0x08</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">1</td><td align="left">40x30 text</td><td align="right">2,400</td></tr>
<tr><td align="left">0x09</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">1</td><td align="left">40x60 text</td><td align="right">4,800</td></tr>
<tr><td align="left">0x0A</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">1</td><td align="left">320x480 True-colour</td><td align="right">614,400</td></tr>
<tr><td align="left">0x0B</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">1</td><td align="left">320x480 High-colour</td><td align="right">307,200</td></tr>
<tr><td align="left">0x0C</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">1</td><td align="left">320x480 256-colour</td><td align="right">153,600</td></tr>
<tr><td align="left">0x0D</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">1</td><td align="left">320x480 16-colour</td><td align="right">76,800</td></tr>
<tr><td align="left">0x0E</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">1</td><td align="left">320x480 4-colour</td><td align="right">38,400</td></tr>
<tr><td align="left">0x0F</td><td align="left">0 (640x480@60)</td><td align="left">0</td><td align="left">1</td><td align="left">320x480 2-colour</td><td align="right">19,200</td></tr>
<tr><td align="left">0x18</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">1</td><td align="left">40x25 text</td><td align="right">2,000</td></tr>
<tr><td align="left">0x19</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">1</td><td align="left">40x50 text</td><td align="right">4,000</td></tr>
<tr><td align="left">0x1A</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">1</td><td align="left">320x400 True-colour</td><td align="right">512,000</td></tr>
<tr><td align="left">0x1B</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">1</td><td align="left">320x400 High-colour</td><td align="right">256,000</td></tr>
<tr><td align="left">0x1C</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">1</td><td align="left">320x400 256-colour</td><td align="right">128,000</td></tr>
<tr><td align="left">0x1D</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">1</td><td align="left">320x400 16-colour</td><td align="right">64,000</td></tr>
<tr><td align="left">0x1E</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">1</td><td align="left">320x400 4-colour</td><td align="right">32,000</td></tr>
<tr><td align="left">0x1F</td><td align="left">1 (640x400@70)</td><td align="left">0</td><td align="left">1</td><td align="left">320x400 2-colour</td><td align="right">16,000</td></tr>
<tr><td align="left">0x28</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">1</td><td align="left">50x37 text</td><td align="right">3,700</td></tr>
<tr><td align="left">0x29</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">1</td><td align="left">50x75 text</td><td align="right">7,500</td></tr>
<tr><td align="left">0x2A</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">1</td><td align="left">400x600 True-colour</td><td align="right">960,000</td></tr>
<tr><td align="left">0x2B</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">1</td><td align="left">400x600 High-colour</td><td align="right">480,000</td></tr>
<tr><td align="left">0x2C</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">1</td><td align="left">400x600 256-colour</td><td align="right">240,000</td></tr>
<tr><td align="left">0x2D</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">1</td><td align="left">400x600 16-colour</td><td align="right">120,000</td></tr>
<tr><td align="left">0x2E</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">1</td><td align="left">400x600 4-colour</td><td align="right">60,000</td></tr>
<tr><td align="left">0x2F</td><td align="left">2 (800x600@60)</td><td align="left">0</td><td align="left">1</td><td align="left">400x600 2-colour</td><td align="right">30,000</td></tr>
<tr><td align="left">0x88</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">1</td><td align="left">40x15 text</td><td align="right">1,200</td></tr>
<tr><td align="left">0x89</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">1</td><td align="left">40x30 text</td><td align="right">2,400</td></tr>
<tr><td align="left">0x8A</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">1</td><td align="left">320x240 True-colour</td><td align="right">307,200</td></tr>
<tr><td align="left">0x8B</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">1</td><td align="left">320x240 High-colour</td><td align="right">153,600</td></tr>
<tr><td align="left">0x8C</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">1</td><td align="left">320x240 256-colour</td><td align="right">76,800</td></tr>
<tr><td align="left">0x8D</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">1</td><td align="left">320x240 16-colour</td><td align="right">38,400</td></tr>
<tr><td align="left">0x8E</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">1</td><td align="left">320x240 4-colour</td><td align="right">19,200</td></tr>
<tr><td align="left">0x8F</td><td align="left">0 (640x480@60)</td><td align="left">1</td><td align="left">1</td><td align="left">320x240 2-colour</td><td align="right">9,600</td></tr>
<tr><td align="left">0x98</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">1</td><td align="left">40x12 text</td><td align="right">960</td></tr>
<tr><td align="left">0x99</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">1</td><td align="left">40x25 text</td><td align="right">2,000</td></tr>
<tr><td align="left">0x9A</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">1</td><td align="left">320x200 True-colour</td><td align="right">256,000</td></tr>
<tr><td align="left">0x9B</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">1</td><td align="left">320x200 High-colour</td><td align="right">128,000</td></tr>
<tr><td align="left">0x9C</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">1</td><td align="left">320x200 256-colour</td><td align="right">64,000</td></tr>
<tr><td align="left">0x9D</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">1</td><td align="left">320x200 16-colour</td><td align="right">32,000</td></tr>
<tr><td align="left">0x9E</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">1</td><td align="left">320x200 4-colour</td><td align="right">16,000</td></tr>
<tr><td align="left">0x9F</td><td align="left">1 (640x400@70)</td><td align="left">1</td><td align="left">1</td><td align="left">320x200 2-colour</td><td align="right">8,000</td></tr>
<tr><td align="left">0xA8</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">1</td><td align="left">50x18 text</td><td align="right">1,800</td></tr>
<tr><td align="left">0xA9</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">1</td><td align="left">50x37 text</td><td align="right">3,700</td></tr>
<tr><td align="left">0xAA</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">1</td><td align="left">400x300 True-colour</td><td align="right">480,000</td></tr>
<tr><td align="left">0xAB</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">1</td><td align="left">400x300 High-colour</td><td align="right">240,000</td></tr>
<tr><td align="left">0xAC</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">1</td><td align="left">400x300 256-colour</td><td align="right">120,000</td></tr>
<tr><td align="left">0xAD</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">1</td><td align="left">400x300 16-colour</td><td align="right">60,000</td></tr>
<tr><td align="left">0xAE</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">1</td><td align="left">400x300 4-colour</td><td align="right">30,000</td></tr>
<tr><td align="left">0xAF</td><td align="left">2 (800x600@60)</td><td align="left">1</td><td align="left">1</td><td align="left">400x300 2-colour</td><td align="right">15,000</td></tr>
</tbody></table>
<h1><a class="header" href="#baseboards" id="baseboards">Baseboards</a></h1>
<h2><a class="header" href="#form-factor" id="form-factor">Form Factor</a></h2>
<p>The original Monotron didn't have a particular form-factor - the PCB was simply made large enough to accept all the desired connectors. The Neotron 32 was upsized slightly to fit the Hammond 1598C series case, however, there were so many connectors packed into a tight space that there was nowhere left fit a full-size SD card slot. The work-around was to use a microSD card, but all available examples proved difficult to hand-solder. An upgrade to the larger Hammond 1598D was investigated, but expansion options for the system still remained limited - there were two small expansion headers, but no real space for any extra connectors.</p>
<p>One of the nice features of the IBM PC (and its clones), and also the Apple II series, was the provision of expansion slots. These allowed extra functionality to be added at a later date - often well beyond what the original designer had envisaged at the time the main system was developed. Whilst the Hammond cases work well as a small desktop chassis, they do lack the space for expansion cards - or at least for expansion cards with their own external connectors.</p>
<p>The alternative would be to produce a board based around the ATX standard - either full-size ATX (305x244mm), micro-ATX (244x244mm), or micro-ITX (170x170mm). These boards would include some crucial components (e.g. audio codec, VGA DAC, power supply), but move much of the other functionality off onto expansion cards (MIDI, Parallel Port, Joystick Ports, etc). Rather than use ISA-style card-edge connectors (which require the expansion card to have a harder gold finish which can survive the plugging-unplugging), we're considering using standard IDC headers. These would, however, be located such that the expansion cards would line up with standard ATX case expansion slot holes.</p>
<h2><a class="header" href="#putting-the-processor-on-a-separate-card" id="putting-the-processor-on-a-separate-card">Putting the processor on a separate card</a></h2>
<p>Unfortunately, being quite a large board means it can be quite expensive to produce. We also note that many of our target CPUs are only supplied in BGA package, which means four layers at a minimum. With a BGA SoC the decoupling capacitors would usually be fitted to the reverse of the board, meaning a simple hot-plate cannot be used for re-flow. This seems to place a high-bar on self-assembly at home - requiring basically a full surface-mount rework station. Instead, it seemed to make sense to locate the complex components on a carrier card (CPU, SDRAM, etc) and leave the main board to carry the through-hole connectors and simpler, lower pin-count, parts like the audio codec.</p>
<p>There are a number of standards we could use for the interface to the processor card:</p>
<ul>
<li><a href="https://learn.adafruit.com/adafruit-feather/feather-specification">Feather</a>: Lots of GPIO (including I²C and SPI) but no defined interface for video, and not specific set of pins assigned for I²S.</li>
<li><a href="https://www.mikroe.com/mikrobus">MikroBus</a>: Designed for expansion cards, rather than processor cards. But our expansion connectors will carry broadly similar sets of pins.</li>
<li><a href="https://download.mikroe.com/flyers/mcu-card-flyer-web.pdf">Mikro MCU Card</a>: Carries almost all of the connections we'd like to get off a SoC (including the all-important RGB LCD interface we need for VGA output). The only downside is the use of two high density 168-pin headers which look pretty tricky to solder, and cost about £4.50 each. </li>
<li><a href="https://www.raspberrypi.org/products/compute-module-3/">Raspberry Pi CM1/CM3</a>: This pinout is quite specific to the BCM2835 and BCM2837 SoCs used, and includes HDMI, Display Serial Interface and Camera Serial Interface. It does support USB and parallel RGB though. </li>
<li><a href="https://www.raspberrypi.org/products/compute-module-4/">Raspberry Pi CM4</a>: This pinout is quite specific to the BCM2711, and if parallel RGB is used, there are no other GPIO pins available. Uses two 100-pin high-density headers.</li>
<li><a href="https://www.sparkfun.com/micromod">SparkFun MicroMod</a>: This is specifically designed to allow different SoCs to be inserted into a baseboard, but the specification does not include pins dedicated to video support. It also uses an M.2 header which is surface-mount and has a 0.5mm pitch.</li>
</ul>
<p>In the end, it's probably easier to come up with our own standard to suit our specific requirements.</p>
<p><img src="https://imgs.xkcd.com/comics/standards.png" alt="Obligatory XKCD reference - 'Standards'" /></p>
<p><a href="https://xkcd.com/927/">https://xkcd.com/927/</a></p>
<p>The signals we need include:</p>
<ul>
<li>Parallel RGB video (8 to 29 pins)
<ul>
<li>3-bit, 6-bit, 9-bit, 12-bit, 15-bit, 18-bit or 24-bit RGB digital video</li>
<li>H-Sync</li>
<li>V-Sync</li>
<li>DDC SDA</li>
<li>DDC SCL</li>
<li>Pixel Clock</li>
</ul>
</li>
<li>2x USB 2.0 Host @ 480 Mbps (4 pins)
<ul>
<li>Port 0 D+</li>
<li>Port 0 D-</li>
<li>Port 1 D+</li>
<li>Port 1 D-</li>
</ul>
</li>
<li>Digital Audio Interface (5)
<ul>
<li>DAC Data</li>
<li>DAC Left/Right Clock</li>
<li>ADC Data</li>
<li>ADC Left/Right Clock</li>
<li>Bit Clock</li>
</ul>
</li>
<li>I²C @ 400 kHz (2)
<ul>
<li>SDA</li>
<li>SCL</li>
</ul>
</li>
<li>Control Signals (10)
<ul>
<li>/Reset (in)</li>
<li>/Enable (in)</li>
<li>8x External Interrupt (in)</li>
</ul>
</li>
<li>Power (8)
<ul>
<li>2x 5.0V @ 2A max, combined</li>
<li>2x 3.3V @ 200mA max, combined</li>
<li>4x GND</li>
</ul>
</li>
<li>SPI Bus @ 25 MHz (11)
<ul>
<li>COPI (out)</li>
<li>CIPO (in)</li>
<li>CLK (out)</li>
<li>8x Chip Select (out)</li>
</ul>
</li>
</ul>
<table><thead><tr><th align="left">Interface</th><th align="left">Pins</th><th align="left">Running Total</th></tr></thead><tbody>
<tr><td align="left">Video</td><td align="left">23</td><td align="left">23</td></tr>
<tr><td align="left">USB</td><td align="left">4</td><td align="left">27</td></tr>
<tr><td align="left">Console UART</td><td align="left">4</td><td align="left">31</td></tr>
<tr><td align="left">PS/2</td><td align="left">4</td><td align="left">35</td></tr>
<tr><td align="left">Digital Audio</td><td align="left">5</td><td align="left">40</td></tr>
<tr><td align="left">I²C</td><td align="left">2</td><td align="left">42</td></tr>
<tr><td align="left">Control</td><td align="left">10</td><td align="left">52</td></tr>
<tr><td align="left">Power</td><td align="left">8</td><td align="left">60</td></tr>
<tr><td align="left">SPI</td><td align="left">11</td><td align="left">71</td></tr>
<tr><td align="left"></td><td align="left">TOTAL</td><td align="left">71 pins</td></tr>
</tbody></table>
<p>This requires at least 71 pins, ideally more as we probably want to include more Ground pins around the high-speed signals. There is a risk that despite this, sending high speed signals (USB 2.0 High-Speed, 40MHz+ parallel RGB) will cause significant EMC issues.</p>
<p>We could include the VGA DAC on the MCU card, reducing the VGA pins from 22 (18x digital RGB + 4) to 7 (3x analog video + 4), but that would then preclude the use of a parallel-RGB to DVI/HDMI encoder at a later date.</p>
<p>If we stick with simple 0.1&quot; pitch pins (easy to solder), one option is two 2xN headers, like the Launchpad uses.</p>
<pre><code>o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
</code></pre>
<p>This has 80 pins, and occupies 51mm by 31mm. As you can see it would produce quite a long CPU card, and seems to waste the space between the two headers. It is, however, the approach taken by the <a href="https://www.waveshare.com/coreh743i.htm">Waveshare CoreH743I board</a> used by the <a href="https://geoffg.net/CMM2_Description.html">Colour Maximite 2</a>.</p>
<p>We could also try a double-square arrangement:</p>
<pre><code>o o o o o o o o o o o o
o o o o o o o o o o o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o                 o o
o o o o o o o o o o o o
o o o o o o o o o o o o
</code></pre>
<p>This has (11 + 9) * 4 = 80 pins, and occupies around 31mm x 31mm, with a central area of 20mm x 20mm to fit the SoC and all the decoupling capacitors. Of course, the general shape can be scaled up if required - the Intel 80386 had a 132-pin PGA package laid out as follows:</p>
<pre><code>o o o o o o o o o o o o o o
o o o o o o o o o o o o o o
o o o o o o o o o o o o o o
o o o                 o o o
o o o                 o o o
o o o                 o o o
o o o                 o o o
o o o                 o o o
o o o                 o o o
o o o                 o o o
o o o                 o o o
o o o o o o o o o o o o o o
o o o o o o o o o o o o o o
o o o o o o o o o o o o o o
</code></pre>
<p>The problem is an LQFP-144 part is 20mm x 20mm by itself, never mind the decoupling caps and the space needed for routing. All things considered, the 2x20 x 2 design may be the best compromise.</p>
<h1><a class="header" href="#example-systems" id="example-systems">Example systems</a></h1>
<p>To demonstrate the practicality of making a portable OS for ARMv7-M, we are in the process of producing a number of Neotron compatible systems. Note that some (or all) of these may never be completed, but all in-progress designs remain available under an open-licence.</p>
<ul>
<li><a href="./neotron_32.html">Neotron 32</a> - an open-source PCB which plugs into the Texas Instruments TM4C Launchpad (a derivative of the original Montron project).</li>
<li><a href="./neotron_340st.html">Neotron 340ST</a> - based on an STM32F7-DISCOVERY PCB; not open-source hardware, but easily available from ST and it comes with schematics.</li>
<li><a href="./neotron_500.html">Neotron 500</a> - an unfinished attempt an an open-source PCB using an STM32H7 and other parts from the JLCPCB catalog so it could be built using their assembly service.</li>
<li><a href="./neotron_600.html">Neotron 600</a> - an open-source PCB which plugs into the Teensy 4.1.</li>
<li><a href="./neotron_1000.html">Neotron 1000</a> - an open-source PCB based around the STM32H7, along with a Lattice iCE40 FPGA for hardware accelerated video output.</li>
<li><a href="./neotron_9X.html">Neotron 9X</a> - an open-source PCB based around the Microchip SAM9X60D5M system-in-package. Possibly not a &quot;Neotron&quot; as it uses a Cortex-A rather than a Cortex-M chip, making it binary-incompatible (although it should be source-compatible).</li>
</ul>
<h1><a class="header" href="#neotron-32" id="neotron-32">Neotron 32</a></h1>
<p>The Neotron 32 is the baby of the Neotron range. As the name suggests, it has just 32 KiB of SRAM (along with 256 KiB of Flash ROM). It is based around a Texas Instruments Launchpad board, and uses the same basic design as the earlier Monotron project.</p>
<h2><a class="header" href="#links" id="links">Links</a></h2>
<ul>
<li>Hardware: <a href="https://github.com/Neotron-Compute/Neotron-32-Hardware">https://github.com/Neotron-Compute/Neotron-32-Hardware</a></li>
<li>BIOS: <a href="https://github.com/Neotron-Compute/Neotron-32-BIOS">https://github.com/Neotron-Compute/Neotron-32-BIOS</a></li>
<li>Main CPU Board: <a href="https://www.ti.com/tool/EK-TM4C123GXL">https://www.ti.com/tool/EK-TM4C123GXL</a></li>
</ul>
<h2><a class="header" href="#features" id="features">Features</a></h2>
<p>The full specifications are:</p>
<ul>
<li><strong>CPU:</strong> Texas Instruments TM4C123 SoC, on a Texas Instruments Tiva-C Launchpad PCB
<ul>
<li><strong>Processor Core</strong>: 80 MHz ARM Cortex-M4F</li>
<li><strong>RAM:</strong> 32 KiB on-die SRAM</li>
<li><strong>ROM:</strong> 256 KiB on-die Flash</li>
<li><strong>GPU:</strong> None - software VGA using 3x SPI interfaces
<ul>
<li>800x600 nominal resolution</li>
<li>400x300 effective resolution</li>
<li>48-column colour text mode and 80-column mono text mode</li>
<li>Maximum 8 colours</li>
</ul>
</li>
</ul>
</li>
<li><strong>Video Output:</strong> SVGA
<ul>
<li>Nominally 800x600 at 60 Hz</li>
<li>Simple 330 ohm terminated video output</li>
</ul>
</li>
<li><strong>Storage:</strong> SD Card slot, supports FAT16/FAT32 and MS-DOS partition tables</li>
<li><strong>USB:</strong> 1x internal USB 2.0 Full-speed micro-AB port</li>
<li><strong>Audio:</strong> 37 kHz PWM audio with three channel wavetable synthesiser
<ul>
<li>3.5mm stereo Line Out</li>
</ul>
</li>
<li><strong>Keyboard/Mouse:</strong> 2x PS/2 Ports (2x 6-pin mini-DIN)</li>
<li><strong>MIDI</strong>: MIDI In and MIDI Out (2x 5-pin 180-degree DIN)</li>
<li><strong>Serial</strong>: RS-232 on 10-pin 2.54mm header suitable for DE-9 plug on IDC ribbon</li>
<li><strong>Parallel</strong>: 3.3v PC-style Parallel Port with DB-25 port
<ul>
<li>Also functions as 3.3v GPIO with 12 outputs and 4 inputs.</li>
</ul>
</li>
<li><strong>Joystick</strong>: 2x 9-pin game ports
<ul>
<li>supports Atari-compatible two-button joysticks, or SEGA MegaDrive/Genesis controllers</li>
</ul>
</li>
<li><strong>Expansion</strong>: 2x internal 2.54mm 2x6 headers carrying power, SPI, I2C and a dedicated IRQ line</li>
<li><strong>RTC</strong>: MCP7940N and coin-cell battery backup</li>
<li><strong>Mechanical Form Factor:</strong> Fits Hammond [1598D] case</li>
</ul>
<p>The Cortex-M4 is responsible for generating the video pixels, at a rate of 40 million mono pixels/second (in high-res text mode) or 20 million colour pixels/second (in all other modes). This leaves only around 4.5% of the CPU available (during the vertical blanking interval) to run your application, which brings the performance down to around the same as a 2 MHz 6502. This is enough to run simple games or a BASIC interpreter. The challenge is to see how much you can squeeze out of such limited resources!</p>
<p>The Neotron 32 uses a Texas Instruments Launchpad board to provide the processing power. This is fitted to a custom PCB which breaks out all of the ports, and adds an AtMega AVR CPU to control the PS/2 and Joystick interfaces. The PCB design is <a href="https://certification.oshwa.org/uk000007.html">registered open-source hardware</a>, and <a href="https://github.com/neotron-compute/neotron-32-hardware">available on Github</a>. The <a href="https://github.com/neotron-compute/neotron-32-bios">ROM BIOS</a> and <a href="https://github.com/neotron-compute/neotron-os">Neotron OS</a> are also fully open-source and available on Github. The ROM BIOS and OS are loaded over the Launchpad's USB debug connection using standard TI Tiva-C flashing tools (such as OpenOCD, or lm4flash). Once flashed, applications can be loaded from a FAT32 formatted SD card.</p>
<h2><a class="header" href="#architecture" id="architecture">Architecture</a></h2>
<p>In a typical 8-bit home computer, the main processor was just a CPU, and all the other peripherals (GPIO ports, RAM, video, etc) were external devices that sat on the processor's address and data bus. On the Neotron 32, the Texas Instruments TM4C123 SoC integrates all of those features (well, not video, but we work around that by misusing some of the serial peripherals) into a single package. The main external interfaces from the SoC are narrow serial buses such as SPI, I²C and UART rather than the wide 8-bit data bus and 16-bit address bus of an 8-bit home computer. The I²C bus is ideal for low-bandwidth peripherals, such as real-time clocks, whilst the SPI bus can be driven at up to 20 MHz, giving 20 Mbit/sec (or around 2400 KiB/sec) making it better for mass storage and networking.</p>
<p>On current revisions of the Neotron 32, the I/O controller (responsible for the PS/2 interfaces and the two Joystick ports) is connected to the main SoC via a UART link. It is likely, however, that this will change to be an I²C based device with an interrupt line in future, following the standard Microsoft HID over I²C Protocol.</p>
<pre><code>+-----------------+
|                 |
|     TM4C123     |
|                 |
+-----------------+
   |   |  | | | |
   |   |  | | | +---&lt;UART&gt; Neotron I/O Controller
   |   |  | | +---&lt;UART&gt; Wi-Fi Modem
   |   |  | +---&lt;UART&gt; RS-232 Interface
   |   |  +---&lt;UART&gt; MIDI In/Out
   |   |
   | &lt;I2C&gt;
   |   |
   |   +-- Real-Time Clock
   |   +-- Neotron I/O Controller (future possibility)
   |   +-- Expansion Port A
   |   +-- Expansion Port B
   |
 &lt;SPI&gt;
   |
   +--- SD Card
   +--- GPIO Port / Parallel Port
   +--- Expansion Port A
   +--- Expansion Port B
</code></pre>
<h1><a class="header" href="#video" id="video">Video</a></h1>
<p>Video is generated on the Neotron-32 by driving three SPI interfaces in a synchronised fashion - one generating a stream of red pixels, one a stream of green pixels and one a stream of green pixels. There is also a Horizontal Sync line driven from a Timer, which is synchronised to the pixel outputs, and a Vertical Sync line which is a GPIO line driven in the Horizontal Scan-line Interrupt Handler.</p>
<p>With a CPU clock of 80 MHz, the SPI ports can be run at either 40 MHz or 20
MHz. 40 MHz generates an 800x600 pixel image with a 60 Hz refresh rate, and
20 MHz generates a 400x600 pixel image with a 60 Hz refresh rate. To counter
the 'stretch' effect of the latter mode, we optionally drop to 300 lines of
video but clocking each out one twice, giving an effective 400x300 resolution
on a nominal 800x600 signal.</p>
<p>The hardware on the motherboard simply consists of some resistors which, in conjunction with the 75 ohm input impedance of a VGA monitor, drops the 3.3V signal from the SoC down to the 0.7V maximum given in the VGA standard. With the three channels (R, G and B) being either on or off, we get 8 familiar colour combinations:</p>
<ul>
<li>Black</li>
<li>Red</li>
<li>Green</li>
<li>Yellow</li>
<li>Blue</li>
<li>Magenta</li>
<li>Cyan</li>
<li>White</li>
</ul>
<p>As the SoC can only just push out the 8 mA required to drive a VGA signal into 75 ohms, later Neotron systems are likely to use a small active VGA/RGB video filter to act as a line driver.</p>
<h2><a class="header" href="#supported-video-modes" id="supported-video-modes">Supported video modes:</a></h2>
<p>The following <a href="./hardware_soc_video.html">video modes</a> are supported:</p>
<ul>
<li>Mode 0x28 - 50x37 text mode at 400x600 </li>
<li>Mode 0xAF - 400x300 2-colour</li>
</ul>
<h1><a class="header" href="#audio" id="audio">Audio</a></h1>
<p>The Neotron 32 generates mono pulse-width-modulated (PWM) audio with 8-bit centre-aligned pulses at a frequency of four times the horizontal video scan rate (giving roughly 151,500 samples per second). At the end of each scan-line, a new 8-bit PCM sample is generated by summing the outputs of three basic wavetable synthesisers. That PCM sample is fed to the PWM hardware at the start of the next scan line (to reduce jitter) and it gets played out four times during that scan line, giving an effective sample rate of just under 38 kHz. The hardware then consists of a simple low-pass filter to remove the PWM carrier frequency, and a headphone jack. As the SoC can't drive a large amount of current, amplified speakers are required.</p>
<p>Each of the three channels on the wavetable synthesiser can produce a square, sawtooth or sine waveforms, or random noise, at a selected frequency. There is also a rudimentary volume control for each channel.</p>
<h1><a class="header" href="#sdmmc" id="sdmmc">SDMMC</a></h1>
<p>The SD Card Slot takes microSD cards (frustratingly, full size SD card slots don't really fit on the front edge with the Joystick ports, because of the placement of the PCB/case screw holes). These are connected up using the <em>SPI Compatibility</em> mode built into all SD and SDHC memory cards. No interrupt line is required - the SD card responds only when polled and gives out repeated <code>0xFF</code> bytes when busy completing an operation.</p>
<h1><a class="header" href="#ps2" id="ps2">PS/2</a></h1>
<p>The Neotron I/O controller is responsible for the PS/2 interfaces and the two Joystick ports. It consists of an AtMega 328 microcontroller with custom firmware, and speaks a bespoke <em>HID over UART</em> protocol. The Joystick ports can be either standard Atari joysticks, or SEGA MegaDrive / Genesis 3-button pads. With some software work, 6-button pads could possibly also be supported.</p>
<p>In the future, we may change this to speak <em>HID over I²C</em> to reduce the number of UARTs required.</p>
<p>Currently the AtMega firmware is written in C++. As Rust on AVR matures we may look to a Rust implementation to allow us to share code with the BIOS.</p>
<h1><a class="header" href="#wifi" id="wifi">WiFi</a></h1>
<p>The Espressif ESP-01 is a Wi-Fi Modem based on the Espressif ESP8266 Wi-Fi chipset. It has an on-board TCP/IP stack, and speaks AT commands. To the Neotron 32 SoC, it basically appears as a classic RS-232 Hayes-compatible AT modem.</p>
<h1><a class="header" href="#parallel-port" id="parallel-port">Parallel Port</a></h1>
<p>The MCP23S17 I/O Expander sits on the SPI bus, with a dedicated IRQ line. This can be used to drive a PC-style 25-pin Parallel Printer Port, or it can be used as a general-purpose 16-bit GPIO interface. Running at up to 10 MHz, all 16-bits can be written to in 4 bytes, which takes 32 microseconds or 256 clock cycles. As the Parallel Port strobe pin is driven separately from an SoC GPIO line, and with the MCP23S17 able to generate an Interrupt when the remote device raises the ACK line, this interface should be sufficient for around 150 KiB/sec.</p>
<h1><a class="header" href="#rs-232" id="rs-232">RS-232</a></h1>
<p>A four-wire (<code>TX</code>, <code>RX</code>, <code>RTS</code>, <code>CTS</code>) RS-232 interface is provided via a 10-pin 0.1&quot; boxed header. These headers are used on old ISA Serial Port expansion cards for when the 9-pin D-Sub (<em>DE9</em>, not <em>DB9</em>) receptacle didn't fit on the edge of the card and had to be moved to a second bracket, one slot over.</p>
<p>The <code>DTR</code>, <code>DSR</code>, <code>DCD</code> and <code>RI</code> pins are not connected.</p>
<h1><a class="header" href="#midi" id="midi">MIDI</a></h1>
<p>MIDI is basically an opto-isolated UART based protocol running at a fixed 31,250 bps. The MIDI In port is connected to UART RX via an opto-isolator, and the MIDI Out port is driven from UART TX via a 5V level shifter (two back-to-back inverters from a hex-inverter).</p>
<h1><a class="header" href="#usb" id="usb">USB</a></h1>
<p>The TM4C Launchpad used in the Neotron 32 has a full-speed (11 Mbps) USB On-The-Go peripheral routed to a USB micro-AB port. This means it is normally a USB Device (e.g. a USB Serial Adaptor, or a USB Human Interface Device), but it can be placed into a mode where it acts as a USB Host. To make this work, we need two things:</p>
<ol>
<li>A USB micro-AB to USB Type-A Receptacle adaptor.</li>
</ol>
<ul>
<li>These adaptors are commonly used with the USB micro-AB ports on a Raspberry Pi.</li>
<li>We could optionally plug in a USB Hub if we wanted to connect more than one USB Device.</li>
</ul>
<ol start="2">
<li>A USB Host stack.</li>
</ol>
<p>The part latter is going to be difficult - the USB protocol intentionally places the burden of work on the Host developer, because that end of the link generally costs more, and has more power available. We have a couple of options available:</p>
<ol>
<li>Use the Texas Instruments Tiva-C <em>usblib</em> stack (https://github.com/yuvadm/stellaris/tree/master/usblib).</li>
<li>Use the USB Host stack from Das U-Boot, or some similar project.</li>
<li>Write a USB Host stack from scratch in Rust.</li>
</ol>
<p>All of these options are out-of-scope for the time being.</p>
<h1><a class="header" href="#rtc" id="rtc">RTC</a></h1>
<p>The TM4C SoC has a battery-backed real-time clock function, but the TM4C Launchpad doesn't break out the battery backup pin and so it will always forget the time when the system is powered off.</p>
<p>Instead, an MCP7940N battery-backed real-time clock chip keeps track of calendar time when the system is powered off, and also offers 64 bytes of battery backed SRAM for system settings. Like on an IBM PC-compatible, removing the battery will &quot;reset&quot; the system settings (on a PC this is known as <em>clearing the CMOS</em>, for various historical reasons).</p>
<h1><a class="header" href="#neotron-pico" id="neotron-pico">Neotron Pico</a></h1>
<p>The Neotron Pico is micro-ATX sized Neotron, powered by a Raspberry Pi Pico microcontroller board. The Raspberry Pi Pico is fitted with a Raspberry Pi RP2040 microcontroller - a dual-core Cortex-M0+ with 256 KiB of SRAM. The Raspberry Pi Pico also has a 2 MiB external QSPI flash.</p>
<p>Whilst the Cortex-M0+ cores are only ARMv6-M compatible (not ARMv7E-M or even ARMv7-M), there were some very compelling advantages in making the switch. For example, compared to the Texas Instruments Tiva-C Launchpad on the Neotron 32, the Raspberry Pi Pico:</p>
<ul>
<li>Has two cores instead of one</li>
<li>Is clocked at 133 MHz instead of 80 MHz (and actually, many units run happily at 250 MHz)</li>
<li>Has 256 KiB of SRAM instead of 32 KiB</li>
<li>Costs £3.60 instead of £15.00</li>
<li>Has hardware designed to generate digital RGB video</li>
<li>Can drive an I²S audio codec</li>
</ul>
<h2><a class="header" href="#form-factor-1" id="form-factor-1">Form Factor</a></h2>
<p>The Neotron Pico is a micro-ATX sized board - 244mm x 170mm. It is designed to fit into any micro-ATX or ATX compatible PC case, and includes headers for a reset switch, power switch, power LED and status LED. It provides four card-edge expansion slots, which provide access to the SPI and I²C buses. Each slot has a unique IRQ line and SPI Chip Select, avoiding the classic IBM PC problem of allocating resources to expansion cards.</p>
<h2><a class="header" href="#links-1" id="links-1">Links</a></h2>
<ul>
<li>Hardware: <a href="https://github.com/Neotron-Compute/Neotron-Pico">https://github.com/Neotron-Compute/Neotron-Pico</a></li>
<li>BIOS: <a href="https://github.com/Neotron-Compute/Neotron-Pico-BIOS">https://github.com/Neotron-Compute/Neotron-Pico-BIOS</a></li>
<li>Raspberry Pi Pico
<ul>
<li>Datasheet: <a href="https://datasheets.raspberrypi.org/pico/pico-datasheet.pdf">https://datasheets.raspberrypi.org/pico/pico-datasheet.pdf</a></li>
</ul>
</li>
<li>Raspberry Pi Silicon RP2040
<ul>
<li>Datasheet: <a href="https://datasheets.raspberrypi.org/rp2040/rp2040-datasheet.pdf">https://datasheets.raspberrypi.org/rp2040/rp2040-datasheet.pdf</a></li>
<li>Hardware Design Guide: <a href="https://datasheets.raspberrypi.org/rp2040/hardware-design-with-rp2040.pdf">https://datasheets.raspberrypi.org/rp2040/hardware-design-with-rp2040.pdf</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#features-1" id="features-1">Features</a></h2>
<ul>
<li><strong>CPU</strong>: Dual 133 MHz 32-bit ARM Cortex-M0+ CPU cores</li>
<li><strong>RAM</strong>: 256 KiB of internal SRAM</li>
<li><strong>Video Output</strong>: Super-VGA
<ul>
<li>640x480 @ 60 Hz (gives a 80x30 text mode)</li>
<li>640x400 @ 70 Hz (gives a 80x25 text mode)</li>
<li>256 colours from a pallette of 4,096</li>
<li>RGB video buffer for genuine 75 Ohm output</li>
<li>Has ESD protection circuit with VGA DDC level-shifter</li>
</ul>
</li>
<li><strong>Audio</strong>: 16-bit 48 kHz audio input and output (line-in, mic-in, line-out and headphone-out)
<ul>
<li>Uses Texas Instruments TLV320AIC23BPW audio codec</li>
<li>Has triple 3.5mm jack, plus AC'97 header and extra four-pin line-in header</li>
</ul>
</li>
<li><strong>Storage</strong>: SD/MMC Slot</li>
<li><strong>USB</strong>: One USB Full-speed OTG port</li>
<li>Dedicated <strong>board management controller (BMC)</strong>, supporting
<ul>
<li><strong>Two PS/2 ports</strong> (keyboard and mouse)</li>
<li><strong>Standby mode</strong> and <strong>PSU control</strong></li>
<li><strong>System reset</strong></li>
</ul>
</li>
<li><strong>Expansion</strong>: Four Expansion Slots (with SPI and I²C)</li>
<li><strong>RTC</strong>: MCP7940N Real-Time Clock with backup battery</li>
</ul>
<h1><a class="header" href="#video-1" id="video-1">Video</a></h1>
<p>Video is generated by the BIOS, through the PIO0 peripheral of the RP2040. Two of its state machines (SM0 and SM1) are used to generate a VGA signal:</p>
<ul>
<li><strong>SM0</strong> - &quot;Timing Program&quot; - generates HSYNC and VSYNC signals</li>
<li><strong>SM1</strong> - &quot;Pixel Program&quot; - generates the actual 16-bit RGB pixels (in pairs)</li>
</ul>
<p>The two state machines are synchronized through the IRQ0 line. Data is carried from the timing and pixel buffers to the PIO0 timing and pixel FIFOs using DMA channels 0 and 1 respectively.</p>
<pre><code>                                                     ┌─┬────┐
                                               ┌────►│H│  0 │
                                               │     ├─┼────┤
                                               ├────►│V│  1 │
                                               │     ├─┼────┤
┌────────────────────────┐                     │     │ │  2 │
│                        │                     │     │ ├────┤
│   ┌────────────────┐   │                     │     │ │  3 │
│   │                │   │                     │  ┌─►│R├────┤
│   │                │   │       ┌───────────┐ │  │  │ │  4 │
│   │     Timing     │   │       │           │ │  │  │ ├────┤
│   │     Buffer     │   │DMA CH0│ ┌──┬────┐ │ │  │  │ │  5 │
│   │                ├───┼───────┼─► F│ SM0├─┼─┘  │  ├─┼────┤
│   └────────────────┘   │       │ └──┴─┬──┘ │    │  │ │  6 │
│                        │       │  IRQ0│    │    │  │ ├────┤
│   ┌────────────────┐   │DMA CH1│ ┌──┬─▼──┐ │    │  │ │  7 │
│   │                ├───┼───────┼─► F│ SM1├─┼────┼─►│G├────┤
│   │                │   │       │ └──┴────┘ │    │  │ │  8 │
│   │     Pixel      │   │       │           │    │  │ ├────┤
│   │     Buffer     │   │       └───────────┘    │  │ │  9 │
│   │                │   │            PIO0        │  ├─┼────┤
│   └────────────────┘   │                        │  │ │ 10 │
│                        │                        │  │ ├────┤
│                        │                        │  │ │ 11 │
└────────────────────────┘                        └─►│B├────┤
           RAM                                       │ │ 12 │
                                                     │ ├────┤
                                                     │ │ 13 │
                                                     └─┴────┘
</code></pre>
<!-- https://asciiflow.com/#/share/eJy9lktuwjAQhq9izZqFHQqF7KCIwiIqTauuvGERqkghCwRSEOIWVQ6DehpOUpMqIo%2FxI07TyI4c2f5nPv92khPE620AbnyIoh5E62OwAxdOHBIO7njo9DgcRcsZDURrHyR78cCB2FzXr2%2B0cB63VEov4r4QldCs00rxP3L8uMVh3eUo67Iruiyy6uQ0sgmFORotlEcBrM3elKFfZkCmGegVffbVNDp1U8I87p3kASd5D7dh%2FCmLVcmkpqojmR42m2BXVp95E%2FK0oLhCmaBOMTDxw7SkFzK%2FKbx5tLZDisZ1uv9M1oFUVmHY6GRlraX%2FSotSxj5a8%2F36zLAIqYbvsRuXmXqYuD%2Br18LgdDb2coSzrsIkiORRaj4buplNwU5ls3WtUYzt3pOr5QstDZAF7O6NXyVh1P6rZehDG03C2D2%2FPyyK2Nf8dExRpsJgf%2BLJdBCkjMax%2B%2BMpqShzaqxGWL9lTvgOhjOcfwAyLhr9) -->
<h2><a class="header" href="#hardware" id="hardware">Hardware</a></h2>
<pre><code>┌───────────────────────────────────────────────────────────────┐
│                          RP2040 GPIO                          │
├─────┬─────┬───┬───┬───┬───┬───┬───┬───┬───┬────┬────┬────┬────┤
│  0  │  1  │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │ 10 │ 11 │ 12 │ 13 │
├─────┼─────┼───┴───┴───┴───┼───┴───┴───┴───┼────┴────┴────┴────┤
│ Hs  │ Vs  │      RED      │     GREEN     │       BLUE        │
└─────┴─────┴───────────────┴───────────────┴───────────────────┘
</code></pre>
<!-- https://asciiflow.com/#/share/eJyrVspLzE1VssorzcnRUcpJrEwtUrJSqo5RqohRsrI0M9OJUaoEsowsQKyS1IoSICdG6dGUPUMdxcTkAUkFnCAowMjAxEDBPcDTH7ciuDlDHcFCwwDsJwUFQwhtBCaNwaQJmDQFk2Zg0hxMWoBJSzBpaAChDCEURLuh8bALJ49iSPiEQWlIinF1gacKMO0e5OrqhyKioODkE%2Bo6%2FFKPUq1SLQDfo6E1) -->
<p>The first 14 GPIO pins of the RP2040 are dedicated to generating the VGA signal. The 4-bits of each color are fed through an R-2R resistor ladder DAC. The analog signals are then fed through a video buffer (<a href="https://www.ti.com/product/THS7316">THS7316</a> or equivalent). The I2C bus of the BMC is also connected to the <a href="https://en.wikipedia.org/wiki/Display_Data_Channel">DDC</a> pins of the VGA port and may be used in the future for display identification purposes.</p>
<p>Physical connection to the screen is done through a <a href="https://www.ti.com/product/TPD7S019">TPD7S019</a> ESD protection circuit and a female DE-15 connector.</p>
<h2><a class="header" href="#supported-video-modes-1" id="supported-video-modes-1">Supported video modes:</a></h2>
<p>The following <a href="./hardware_soc_video.html">video modes</a> are supported:</p>
<ul>
<li>Mode 0x00 - 80x30 text mode at 640x480</li>
<li>Mode 0x01 - 80x60 text mode at 640x480</li>
<li>Mode 0x10 - 80x25 text mode at 640x400</li>
<li>Mode 0x11 - 80x50 text mode at 640x400</li>
<li>Mode 0x91 - 80x25 text mode at 640x200</li>
<li>Mode 0x05 - 640x480 in 16 colours</li>
<li>Mode 0x06 - 640x480 in 4 colours</li>
<li>Mode 0x07 - 640x480 in 2 colours</li>
<li>Mode 0x15 - 640x400 in 16 colours</li>
<li>Mode 0x16 - 640x400 in 4 colours</li>
<li>Mode 0x17 - 640x400 in 2 colours</li>
<li>Mode 0x94 - 640x200 in 256 colours</li>
<li>Mode 0x95 - 640x200 in 16 colours</li>
<li>Mode 0x96 - 640x200 in 4 colours</li>
<li>Mode 0x97 - 640x200 in 2 colours</li>
<li>Mode 0x8C - 320x240 in 256 colours</li>
<li>Mode 0x8D - 320x240 in 16 colours</li>
<li>Mode 0x8E - 320x240 in 4 colours</li>
<li>Mode 0x8F - 320x240 in 2 colours</li>
<li>Mode 0x9C - 320x200 in 256 colours</li>
<li>Mode 0x9D - 320x200 in 16 colours</li>
<li>Mode 0x9E - 320x200 in 4 colours</li>
<li>Mode 0x9F - 320x200 in 2 colours</li>
</ul>
<h1><a class="header" href="#neotron-340st" id="neotron-340st">Neotron 340ST</a></h1>
<p>The Neotron 340ST is based on the ST 32F746G-DISCOVERY. This is an off-the-shelf evaluation-kit aimed at the hobbyist market featuring an STM32F7 SoC, a colour LCD display, audio output jack and expansion headers. It is not open-source hardware, but it is easily available from ST and it comes with schematics.</p>
<h2><a class="header" href="#links-2" id="links-2">Links</a></h2>
<ul>
<li>Hardware: <a href="https://www.st.com/en/evaluation-tools/32f746gdiscovery.html">https://www.st.com/en/evaluation-tools/32f746gdiscovery.html</a></li>
<li>BIOS: <a href="https://github.com/Neotron-Compute/Neotron-340ST-BIOS">https://github.com/Neotron-Compute/Neotron-340ST-BIOS</a></li>
<li>Main CPU: <a href="https://www.st.com/content/st_com/en/products/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus/stm32-high-performance-mcus/stm32f7-series/stm32f7x6/stm32f746ng.html">https://www.st.com/content/st_com/en/products/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus/stm32-high-performance-mcus/stm32f7-series/stm32f7x6/stm32f746ng.html</a></li>
</ul>
<h2><a class="header" href="#features-2" id="features-2">Features</a></h2>
<ul>
<li>216 MHz 32-bit ARM Cortex-M7 CPU core</li>
<li>320 KiB of on-chip SRAM</li>
<li>8 MiB 16-bit SDRAM</li>
<li>16 MiB QuadSPI Flash</li>
<li>480x272 colour TFT LCD</li>
<li>Cirrus WM8994ECS Audio codec with:
<ul>
<li>Stereo line output</li>
<li>Stereo speaker output</li>
<li>Stereo line input</li>
<li>S/PDIF input</li>
<li>Stereo on-board microphones</li>
</ul>
</li>
<li>One high-speed (480 Mbps) USB 2.0 OTG (AB) port in Host mode</li>
<li>One full-speed (12 Mbps) USB 2.0 OTG (AB) port in Host mode</li>
<li>microSD Slot</li>
<li>10/100 Ethernet Port</li>
<li>DCMI digital camera input</li>
<li>Arduino headers (3.3V)</li>
<li>On-board ST-Link/V2-1 programmer/debugger, with USB Serial interface</li>
<li>7-12V DC barrel jack for power input</li>
</ul>
<h1><a class="header" href="#neotron-500" id="neotron-500">Neotron 500</a></h1>
<p>The Neotron 500 is an unfinished attempt an an open-source PCB using an STM32H7. The idea was to only use parts from the JLCPCB catalog so that it could be built using their low-cost surface-mount PCB Assembly service. Unfortunately, it transpires that the STM32H7's QuadSPI controller only supports Flash ROM, not SRAM, meaning to get the targeted 8 MiB of RAM, a DDR SDRAM chip would be required. Currently that appears to be more difficult to lay out, and so the project was abandoned in favour of the Neotron 600.</p>
<p>It should also be noted that almsot all STM32 F7 and H7 series parts currently do not include a High-Speed USB2.0 PHY, instead requiring an external ULPI PHY. There are some very new parts which do include a USB2.0 High-Speed PHY, but they don't include a TFT controller.</p>
<h2><a class="header" href="#links-3" id="links-3">Links</a></h2>
<ul>
<li>Hardware: <a href="https://github.com/Neotron-Compute/Neotron-500-Hardware">https://github.com/Neotron-Compute/Neotron-500-Hardware</a></li>
<li>BIOS: <a href="https://github.com/Neotron-Compute/Neotron-500-BIOS">https://github.com/Neotron-Compute/Neotron-500-BIOS</a></li>
<li>Main CPU: <a href="https://www.st.com/en/microcontrollers-microprocessors/stm32h743ii.html">https://www.st.com/en/microcontrollers-microprocessors/stm32h743ii.html</a></li>
</ul>
<h2><a class="header" href="#features-3" id="features-3">Features</a></h2>
<ul>
<li>480 MHz 32-bit ARM Cortex-M7 CPU core</li>
<li>1024 KiB of internal ECC SRAM</li>
<li>8 MiB external DRAM</li>
<li>Super-VGA output
<ul>
<li>640x480</li>
<li>800x600</li>
<li>256 colours from a pallette of 262,144</li>
</ul>
</li>
<li>16-bit 48 kHz audio input and output (line-in, mic-in, line-out and headphone-out)</li>
<li>Four high-speed (480 Mbps) USB 2.0 ports
<ul>
<li>Two USB A ports on-board</li>
<li>Header for additional two ports</li>
</ul>
</li>
<li>IEEE-1284 Parallel Port</li>
<li>RS232 Port (five-wire)</li>
<li>SD/MMC Slot</li>
<li>PS/2 Keyboard and Mouse ports</li>
<li>2x Atari/Sega joystick ports</li>
<li>Battery-backed Real-time Clock and CMOS RAM</li>
<li>SPI and I2C based expansion bus</li>
</ul>
<h1><a class="header" href="#neotron-600" id="neotron-600">Neotron 600</a></h1>
<p>The Neotron 600 is an open-source PCB which plugs into the Teensy 4.1. Using the Teensy 4.1 gives it excellent performance, an Ethernet PHY and a support for an easy-to-fit external QuadSPI SRAM chip. The only downside is that the pinout limits the colour output to 7 bits (128 colours).</p>
<h2><a class="header" href="#links-4" id="links-4">Links</a></h2>
<ul>
<li>Hardware: <a href="https://github.com/Neotron-Compute/Neotron-600-Hardware">https://github.com/Neotron-Compute/Neotron-600-Hardware</a></li>
<li>BIOS: <a href="https://github.com/Neotron-Compute/Neotron-600-BIOS">https://github.com/Neotron-Compute/Neotron-600-BIOS</a></li>
<li>Main CPU: <a href="https://www.nxp.com/products/processors-and-microcontrollers/arm-microcontrollers/i-mx-rt-crossover-mcus/i-mx-rt1060-crossover-mcu-with-arm-cortex-m7-core:i.MX-RT1060">https://www.nxp.com/products/processors-and-microcontrollers/arm-microcontrollers/i-mx-rt-crossover-mcus/i-mx-rt1060-crossover-mcu-with-arm-cortex-m7-core:i.MX-RT1060</a></li>
</ul>
<h2><a class="header" href="#features-4" id="features-4">Features</a></h2>
<ul>
<li><strong>Processor Module</strong>: Teensy 4.1
<ul>
<li><strong>CPU:</strong> NXP i.MX RT1062 SoC
<ul>
<li><strong>Core</strong>: 600 MHz Cortex-M7</li>
<li><strong>RAM:</strong> 1024 KiB FlexRAM</li>
<li><strong>ROM:</strong> 128 KiB Boot ROM (factory programmed mask ROM)</li>
<li><strong>GPU:</strong> NXP i.MXRT LCD Controller
<ul>
<li>1366x768 maximum resolution</li>
<li>Supports bitblit, rotation, alpha, chroma-key</li>
</ul>
</li>
</ul>
</li>
<li>8 MiB Flash</li>
<li>8 MiB QuadSPI SRAM (optional)</li>
<li>10/100 Ethernet PHY</li>
</ul>
</li>
<li><strong>Video Output:</strong> SVGA
<ul>
<li>Nominally 800x600 at 60 Hz</li>
<li>Other resolutions TBD (depends on pixel clock)</li>
<li>Texas Instruments THS7316 Video Amplifier used to drive 75 ohm VGA output</li>
<li>2x 2-bit + 1x 3-bit 0.1% R2R DACs, to give max 128 (2^7) colours</li>
</ul>
</li>
<li><strong>Storage:</strong> SD Card slot, supports FAT16/FAT32 and MS-DOS partition tables</li>
<li><strong>USB:</strong> 2x external USB 2.0 Full-speed Type-A Host ports (with a header for two more)</li>
<li><strong>Audio:</strong> 16-bit 48 kHz stereo
<ul>
<li>Wolfson WM8731 Audio CODEC</li>
<li>3.5mm stereo Line Out</li>
<li>3.5mm stereo Amplified headphone output</li>
<li>Digital volume control</li>
</ul>
</li>
<li><strong>Keyboard/Mouse:</strong> 2x PS/2 Ports (2x 6-pin mini-DIN)</li>
<li><strong>Serial</strong>: RS-232 on 10-pin 2.54mm header suitable for DE-9 plug on IDC ribbon, MAX3232 transceiver</li>
<li><strong>Ethernet</strong>: Standard 100base-TX RJ45 port (driven from PHY on Teensy 4.1)</li>
<li><strong>Expansion</strong>: 4x internal 2.54mm 2x6 headers carrying power, SPI, I2C and a dedicated IRQ line</li>
<li><strong>RTC</strong>: MCP7940N RTC and coin-cell battery backup</li>
<li><strong>Mechanical Form Factor:</strong> microATX</li>
</ul>
<h1><a class="header" href="#neotron-1000" id="neotron-1000">Neotron 1000</a></h1>
<p>The Neotron 1000 is the full-fat, top-of-the-line Neotron, packed into the same form factor as a Raspberry Pi 4. It has an STM32H7 driving one video output, and a Lattice Semi iCE40 FPGA driving a second video output - both via HDMI encoders.</p>
<h2><a class="header" href="#features-5" id="features-5">Features</a></h2>
<ul>
<li><strong>CPU</strong>: STMicroelectronics H7 Series CPU 400MHz</li>
<li><strong>Memory</strong>: 8MB DRAM</li>
<li><strong>GPU</strong>: Lattice ICE40 Series Soft Core (Hardware Accelerated Rendering)</li>
<li><strong>GPU RAM</strong>: 16MB SRAM</li>
<li><strong>Storage</strong>: SD Card Slot</li>
<li><strong>Network</strong>: 10Base-T Ethernet</li>
<li><strong>USB</strong>: 2x USB2 High speed host ports</li>
<li><strong>Audio</strong>: Line Out / In Combo Jack</li>
<li><strong>Video</strong>: Dual HDMI (1 CPU, 1 GPU)</li>
<li><strong>Other IO</strong>: PS2 Keyboard/Mouse Port, Pi compatible Hat Connector (40 pin)</li>
<li><strong>Mechanical Form Factor</strong>: Raspberry Pi 4B</li>
</ul>
<h1><a class="header" href="#neotron-9x" id="neotron-9x">Neotron 9X</a></h1>
<p>If the Neotron 32 is like a BBC Micro, the Neotron 9X is like an Acorn RISC PC. It uses the Microchip SAM9X system-in-package, which bundles DDR SDRAM alongside the SoC in the same package. This hugely simplifies PCB routing as compared to the Neotron 500.</p>
<p>As it runs an ARM9 core and has 64 MiB of DDR2 SDRAM, it would run RISC OS, or even Linux quite happily. In future, we may develop a RISC OS or Windows 95 like shell which sits above the Neotron OS. Performance wise, this system is broadly similar to a mid-1990s Pentium 200 MMX.</p>
<p>Because the ARM9 will not run Cortex-M3/4/7 (i.e. ARMv7-M or ARMv7E-M) machine code, it is incompatible with standard Neotron applications, and they will need to be recompiled for the ARM9 (i.e. ARMv5TE architecture). You could make an argument, therefore, that the Neotron 9X isn't a Neotron at all.</p>
<h2><a class="header" href="#links-5" id="links-5">Links</a></h2>
<ul>
<li>Hardware: <a href="https://github.com/Neotron-Compute/Neotron-9X-Hardware">https://github.com/Neotron-Compute/Neotron-9X-Hardware</a></li>
<li>BIOS: <a href="https://github.com/Neotron-Compute/Neotron-9X-BIOS">https://github.com/Neotron-Compute/Neotron-9X-BIOS</a></li>
<li>Main CPU: <a href="https://www.microchip.com/wwwproducts/en/SAM9X60D5M">https://www.microchip.com/wwwproducts/en/SAM9X60D5M</a></li>
</ul>
<h2><a class="header" href="#features-6" id="features-6">Features</a></h2>
<ul>
<li><strong>CPU:</strong> Microchip SAM9X60D5M System-in-Package
<ul>
<li><strong>Processor Core</strong>: 600 MHz ARM926EJ-S
<ul>
<li>32 KiB Instruction Cache</li>
<li>32 KiB Data Cache</li>
<li>Memory Management Unit</li>
</ul>
</li>
<li><strong>RAM:</strong> 64 MiB on-package DDR2
<ul>
<li>Also has 64 KiB on-die SRAM</li>
</ul>
</li>
<li><strong>ROM:</strong> 256 KiB Serial Flash
<ul>
<li>Can load BIOS from &quot;boot.bin&quot; on SD-Card, like an Amiga 1000 loads Kickstart from floppy disk</li>
<li>Can also load BIOS into RAM from Serial Flash</li>
</ul>
</li>
<li><strong>GPU:</strong> Microchip SAM9 LCD Controller
<ul>
<li>800x600 resolution (chip supports up to 1024x768 resolution maximum)</li>
<li>Typically 16 or 256 colour pallete mode to save Video RAM</li>
<li>Optional 16-bit mode for improved colour depth</li>
<li>Three hardware overlays with transparency</li>
<li>Hardware scaling</li>
</ul>
</li>
<li><strong>GPU RAM:</strong> Shared with main SDRAM</li>
</ul>
</li>
<li><strong>Video Output:</strong> SVGA
<ul>
<li>Nominally 800x600 at 60 Hz</li>
<li>Other resolutions TBD (pixel clock is limited to integer divisors of system clock)</li>
<li>Texas Instruments THS7316 Video Amplifier used to drive 75 ohm VGA output</li>
<li>Triple 6-bit 0.1% R2R DACs, to give max 262,144 (2^18) colours</li>
</ul>
</li>
<li><strong>Storage:</strong> SD Card slot, supports FAT16/FAT32 and MS-DOS partition tables</li>
<li><strong>USB:</strong> 2x external USB 2.0 Full-speed Type-A Host ports (with a header for one more)</li>
<li><strong>Audio:</strong> 16-bit 48 kHz stereo
<ul>
<li>Wolfson WM8731 Audio CODEC</li>
<li>3.5mm stereo Line Out</li>
<li>3.5mm stereo Amplified headphone output</li>
<li>Digital volume control</li>
</ul>
</li>
<li><strong>Keyboard/Mouse:</strong> 2x PS/2 Ports (2x 6-pin mini-DIN)</li>
<li><strong>Serial</strong>: RS-232 on 10-pin 2.54mm header suitable for DE-9 plug on IDC ribbon</li>
<li><strong>Ethernet</strong>: Standard 100base-TX RJ45 port.</li>
<li><strong>Expansion</strong>: 4x internal 2.54mm 2x6 headers carrying power, SPI, I2C and a dedicated IRQ line</li>
<li><strong>RTC</strong>: Coin-cell battery backup for the main CPU's RTC.</li>
<li><strong>Mechanical Form Factor:</strong> microATX</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
